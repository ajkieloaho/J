\section*{Preface}  % preface
	\addcontentsline{toc}{section}{Preface}
\label{preface}
The most important change in the new J3.0 is that the software is made
open source. Initially I made the software so that only I could understand
the structure and the code. When Reetta Lempinen started to work with me
in version 2.0 incorporating factory problems, I learned what are the
weakest points in the software if it should be maintained by a group of
people. But as I was always able to tell Reetta how the software worked,
only very slight improvements in the documentation etc. were made.
When I realized that my retirement age is approaching, I started to worry
how the software could be maintained after my retirement. In 2014
when we were looking at how \textbf{J} could be utilized in Me-la software,
I encountered old JLP concept ‘own function’, which was the method
for allowing users of JLP to add own (arithmetic) functions if they
had access to the source code. Adding these two things together
I realized how \textbf{J} should be restructured so that it could be better
maintained and how different users could add their own \textbf{J} functions,
object types and options.
I was then convinced that the best way to utilize these improvements
would be to make the soft-ware open source. This would also allow me
to continue my work with \textbf{J} after my retirement. So I started to make
necessary changes that different users could start to maintain and
develop \textbf{J} source code. This meant changes in the file structure and
data structures and additional documentation. By changing the data
structures, \textbf{J} also became significantly faster (main reason was that
I made allocatable pointers were changed into allocatable arrays).
I made also a precompiler which allows the users access global module
global variables without knowing where they are. To separate the
global variables from user’s own variables, they are separated
by j\_ -prefix.
At least in this initial phase of the open \textbf{J} project, we did not
try to comment all existing \textbf{J} functions. The purpose is to give the
user enough information that she/he can make own functions, object
types and options and access old object types and options.  Old \textbf{J}
functions do not show good examples how to make \textbf{J} functions, as I
made just for this open \textbf{J} project general purpose utility functions
for starting a function and accessing options, and these are not
utilized in the old code. Old \textbf{J} functions utilize directly the
information of how the interpreted \textbf{J} code is organized. ‘User’s
guide to own J3.0 packages’ describes how the user can develop
and maintain \textbf{J} code.
The previous version utilized some subroutines of IMSL package and
from the ‘Numerical Recipes in Fortran’ book.  These are now replaced
mainly by open access routines from Lapack and Ranlib packages from
the Netlib library. Roger Fletcher allowed to distribute his linear
programming sub-routines in the open \textbf{J} package (see the Conditions
of the use for the conditions).??
The users are invited to develop the new open \textbf{J} software. This first
version could be better documented, but I think that it is according
to the open source ideas that software can be opened even if it is
not so completely clean. I try to bear the shame for the poor
documentation.
Suonenjoki. dd mm 2021
\textbf{J}uha Lappi
\section*{Changes from previous versions}  % changes
	\addcontentsline{toc}{section}{Changes from previous versions}
\label{changes}
The software is almost  completely rewritten. There are many new functions and properties. In
this section only such changes are described which prevent old users to use their old script files.
The graphics is now using Gnuplot as graphics server. Gnuplot is freely available. It should be installed so
that \textbf{J} finds it from the path. \textbf{J} launches Gnuplot automatically when plotting figures. Now publication level
figures can be made directly using \textbf{J} as previoysly it could be produced by asking \textbf{J} to write R scripts
to the disk. Old plotting functions should work.
If variable names are given at the beginning  of a data file, this must be told to \textbf{J} differently.
\section{Introduction}
\label{intro}
The \textbf{J} software can be used as is, i.e. using exe files. The User guide concentrates
on using binary files, but some reference is aslo made to additional possiblities offered
by the open \textbf{J} code which Luke finally after 7 years deadlock allowed to publish.
\subsection{Using exe files}
\label{intro1}
\textbf{J} is a general program for many different tasks. In one end, \textbf{J} is a programming language which
can be used to program several kind of applicatios and tasks, starting from computing 1+1, either
can do several tasks in statistics, plotting figures,
using \textcolor{VioletRed}{jlp}() function can take several hours.
The general \textbf{J} functions and \textbf{J} trasformations can be combined in many ways.
!
The development of new \textbf{J} applications is made easier with special input programming. Input
programming can generate efficiently several \textbf{J} code lines with few lines so that any part of
object names can be have indices. \textbf{J} scripts can be read from include files which can contain
sections, so that all code of a project can be stored in one file. Different sections can
be executed by just writing the name of the section at \textcolor{Red}{sit>} prompt.
!
The code development is easy using efficient debugging tools. The output of a \textbf{J} function is printed
if the line ends with ';' or ';;'. After the code development, the printing can be put off without
changing the code by telling with \textcolor{teal}{Printresult} variable whether ';' or ';;' or - results
are printed. During \textcolor{VioletRed}{pause}() the user can do any computations and print objects and
then either continue or interrupt the process. With \textcolor{teal}{Debugconsole} variable the user can
tell whether \textcolor{VioletRed}{pause}() is generated after each command line read from an include file. With
\textcolor{teal}{Debugcode} the user can tell wther \textcolor{VioletRed}{pause}() is generated after each line when \textbf{J} excecutes
code made by the interpreter and which is packed into a transformation object.
\textbf{J} is now efficient program to do many kind matrix computations. After retirement I sold a client
and thus learned Matlab. Then I implemented all Matlab properties I found useful.
all arithemetical, trigonometric and logical funtions cand operate both on scalars and matrices.
Some useful extensios to normal computation rules were addewd. Matrices can be made
from submatrices, submatrices can be extracted from matrices and replaced by other
matrices.
!
The list object is used to transimit and acces object lists. If the list elements are
objects called REAL variables, the the list can be used in matrix computaions
!
The input programming  has the following functions and capabilities.
\begin{itemize}
\item objstart"i"end \,\textcolor{green}{!\,replaces\,i\,in\,the\,text\,with\,the\,integer\,value\,of\,i.\,Combined\,with\,\textcolor{Red}{;do}()}
this provides possiblitesd to generate large numer of lines using only some linse
\textcolor{Red}{;goto}() \,\textcolor{green}{!\,code\,is\,obtained\,from\,a\,different\,place\,of\,an\,include\,file.}
;elseif();then \\
;else \\
;endif
\end{itemize}
\textbf{J} functions can have arguments and options. Options are used to trasnmit optional arguments
to a function. Options are expressed as option->. If the option does not refer to a single object then
the value of the option must be put into parentrhesi.In some cases the prence or absence of an argument passes an logical
argument into a function. There tow groups of options, ordinaryy options and code options.
Ordinalry options treansmit either object names or numeric values into a function.
code options contain a short peice of code which is computed several times form within the function.
E.g. \textcolor{blue}{func->}\textcolor{VioletRed}{sin}(x) can tells the \textcolor{VioletRed}{draw}() function waht is the function to be drawn. If
computation of the codeoption rquires several lines, then thes lines can be
then the \textcolor{blue}{func->}tr(\textcolor{teal}{res}) is used to tell how the function value is computed.
\subsection{The components of the software package available in Github}
\label{pack}
!
\subsection{\textbf{J} functions}
\label{jfuncs0}
The general (non arithmetic) \textbf{J} functions are used either in statements
func(arg1,…,argn,opt1->value1,….,optm->valuem)
or
output=func(arg1,…,argn,opt1->value1,….,optm->valuem)\\
If there is no output for a function in a statement, then there can be three different cases:
i) The function does not produce any output (if an output would be given, then \textbf{J} would just
ignore it\\
ii) The function is producing output, and a default name is used for the output (e.g. Result
for arithmetic and matrix operations, Figure in graphic functions).\\
iii) The function is a sub expression within a transformation consisting of several parts including
other function or arithmetic operations. Then the output is put into a temporary unnamed
object which is used by upper level functions as an argument (e.g. a=\textcolor{VioletRed}{inverse}(b)*t(c))
If the value of an option is not a single object or numeric constant, then it must be enclosed in
parenthesis.\\
It is useful to think that options define additional argument sets for a function. Actually
an alternative for options would be to have long argument lists where the position of an
argument determines its interpretation. Hereafter generic term 'argument' may refer also to
the value of an option.
When \textbf{J} is interpreting a function, it is checking that the option names and the syntax
are valid, but it is not checking if an option is used by the function. Also when executing the
function, the function is reacting to all options it recognizes but it does not notice if there are
extra options, and these are thus just ignored.
An argument for a \textbf{J} function can be either functional statements producing a \textbf{J} object as its
value, or a name of \textbf{J} object. Some options can be without any argument (indicating that the
option is on).
An essential feature in \textbf{J} functions is that the driver subroutine which is computing
the functions is recursive. This recursion is used when code options SEE? are used to compute
the the output of an code option or when transformation objects are explcitly called
within an transformation object or a function dealing with data is computing \textcolor{blue}{trans->} transforamtion for each
observation.
\\
a = \textcolor{VioletRed}{sin}(\textcolor{VioletRed}{cos}(c)+b) &\textcolor{green}{!\,Usual\,arithmetic\,functions\,have\,numeric\,values\,as}
\\
arguments
\\
here the value of the argument of cos is obtained by 'computing' the
\\
value of real variable c.
\\
\\
\textcolor{VioletRed}{stat}(D,H,\textcolor{blue}{min->},\textcolor{blue}{max->}) &\textcolor{green}{!\,Here\,arguments\,must\,be\,variable\,names}
\\
\\
\textcolor{VioletRed}{plotyx}(H,D,\textcolor{blue}{xrange->}(\textcolor{VioletRed}{int}(D\%min,5), \textcolor{VioletRed}{ceiling}(D\%max,5))) &\textcolor{green}{!arguments\,of}
\\
the function are variables, arguments of option \textcolor{blue}{xrange->} are numeric
\\
values
\\
\\
c = \textcolor{VioletRed}{inverse}(h+\textcolor{VioletRed}{t}(g)) &\textcolor{green}{!\,The\,argument\,can\,be\,intermediate\,result\,from}
\\
matrix computations.
\\
If it is evident if a function or option should have object names or values as their arguments, it
\\
is not indicated with a special notation. If the difference is emphasized, then the values are
\\
indicated by val1,…valn, and objects by obj1,…,objn, or the names of real variables are
\\
indicated by var1,…,varn.
\\
There are some special options which do not refer to object names or values. Some options
\\
define a small one-statement transformation to be used to compute something repeatedly.
\\
\\
\textcolor{VioletRed}{stat}(D,H,\textcolor{blue}{filter->}(\textcolor{VioletRed}{sin}(D).gt.\textcolor{VioletRed}{cos}(H+1)) &!
\\
only those observations are
\\
accepted which pass the filter
\\
\\
\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}(\textcolor{VioletRed}{sin}(\$x)+1),\textcolor{blue}{x->}\$x,\textcolor{blue}{xrange->}(0,10,1)) &\textcolor{green}{!\,the\,\textcolor{blue}{func->}\,option}
\\
transmits the function to be drawn not a single value.
\\
\subsection{Structure of general \textbf{J} functions}
\label{jfunc}
The general (non arithmetic) \textbf{J} functions are used either in statements
func(arg1,…,argn,opt1->value1,….,optm->valuem)
or
output=func(arg1,…,argn,opt1->value1,….,optm->valuem)
If there is no output for a function in a statement, then there can be three different cases:
\begin{itemize}
\item[\textbf{J}] The function does not produce any output (if an output would be given, then \textbf{J} would just
ignore it
\item[\textbf{J}] The function is producing output, and the default name {Result} is used for the output
for arithmetic and matrix operations.
\item[\textbf{J}] The function is a sub expression within a transformation consisting of several parts including
other function or arithmetic operations. Then the output is put into a temporary unnamed
object which is used by upper level functions as an argument (e.g. a=\textcolor{VioletRed}{inverse}(b)*t(c))
\end{itemize}
If the value of an option is not a single object or numeric constant, then it must be enclosed in
parenthesis.
\begin{note}
It is useful to think that options define additional argument sets for a function. Actually
an alternative for options would be to have long argument lists where the position of an
argument determines its interpretation. Hereafter generic term 'argument' may refer also to
the arguments of an option.
\end{note}
\begin{note}
When \textbf{J} is interpreting a function, it is checking that the option names and the syntax
are valid, but it is not checking if an option is used by the function. Also when executing the
function, the function is reacting to all options it recognizes but it does not notice if there are
extra options, and these are thus just ignored.
An argument for a \textbf{J} function can be either functional statements producing a \textbf{J} object as its
value, or a name of \textbf{J} object. Some options can be without any argument (indicating that the
option is on).
\end{note}
\begin{example}[jfuncex]Examples of J-functions\\
\label{jfuncex}
a = \textcolor{VioletRed}{sin}(\textcolor{VioletRed}{cos}(c)+b) \textcolor{green}{!\,Usual\,arithmetic\,functions\,have\,numeric\,values\,as\,arguments}\\
\textcolor{green}{!\,here\,the\,value\,of\,the\,argument\,of\,cos\,is\,obtained\,by\,'computing'\,the\,value\,of\,real\,variable\,c.}\\
Dm=\textcolor{VioletRed}{matrix}(\textcolor{blue}{do->}(0.1,40))\\
nob=\textcolor{VioletRed}{nrows}(Dm)\\
e=\textcolor{VioletRed}{matrix}(nob)\\
e=\textcolor{VioletRed}{rann}()\\
Hm=0.5+Dm**0.7+e\\
dat=\textcolor{VioletRed}{newdata}(Dm,Hm,\textcolor{blue}{read->}(D,H))\\
\textcolor{VioletRed}{stat}(D,H,\textcolor{blue}{min->},\textcolor{blue}{max->}) \textcolor{green}{!\,Here\,arguments\,must\,be\,variable\,names}\\
\textcolor{VioletRed}{plotyx}(H,D) \textcolor{green}{!arguments\,of\,the\,function\,are\,variables}\\
h=\textcolor{VioletRed}{matrix}(5,5);\\
h=\textcolor{VioletRed}{rann}();\\
g=\textcolor{VioletRed}{matrix}(5,\textcolor{blue}{do->}5);\\
c = \textcolor{VioletRed}{inverse}(h+\textcolor{VioletRed}{t}(g)); \textcolor{green}{!\,The\,argument\,can\,be\,intermediate\,result\,from\,matrix\,computations.}
\end{example}
\subsection{\textbf{J} objects}
\label{objintro}
\textbf{J} objects have a simple yet efficient structure. Each object is associate with a double precision
variable, two integer vectors, one single precision vector, one double precision vector,
one vector of characters and one vector of text lines. All vectors are allocated dynamically.
There are several object types which store data differently in these vectors.
Object can be either simple or compound objects. Compound objects are linked to other
objects which can be used also directly utilizing the standard naming conventions. All objects are
global, i.e. also users can acces all objects even if some predefined objects are locked so that
users cannot change them.
\subsection{System requirement}
\label{system}
The current binary versions of \textbf{J} are developed using Gfortran Fortran 90 compiler in MSYS2 MINGW 64-bit environment
under Windows 10. There are both release and debug versions available.
Binary versions are ordinary console applications. It is recommended that \textbf{J} is used in command
prompt window, so that
if execution of \textbf{J} terminates unexpectedly, the error debugging information, remains visible.
With the debug version the problematic line is indicated.
See chapter ? for more information of error handling.
See J3.0 Development Guide to start develop the software or to add
own functions. The development package contains, in addition to source code for
the standard \textbf{J} software, program Jmanual
which can be used to generate Latex code for the manual, program Jindent to make indentations for
Fortran source files and
a precompiler Jpre which writes necessary Fortran statements to access all globa \textbf{J} data structures.
Figures are made with Gnoplot.
Gnuplot is freely available at
https://sourceforge.net/projects/gnuplot/files/gnuplot/5.4.2/
Download  download gp542-win64-mingw.exe. This will install gnuplot on your windows
system under C:\Program Files\gnuplot\. \textbf{J} will strat Gnuplot automatically when
plotting figures.
\subsection{Set-up of \textbf{J}}
\label{setup}
The maximum number of available objects cannot be changed during a \textbf{J} session. It is determined during
the initialization. When \textbf{J} is started it tries to read first file j.par from the default directory
(see 'During the first use' chapter): The first line must look like
*2000
where the number gives the maximum number of named objects.  If j.par is not available, the default
number of objects is 5000.
Thereafter there can be in j.par file any number of \textbf{J} commands executed directly (e.g.
you can give shortcuts for
commands which are handy e.g. when including repeatedly certain sections from include files). If you
want to go directly into a specific J-application, you can put into j.par the corresponding include
command.
If \textbf{J} is started from command prompt, there can be an include file name in the command line. This
include file is run after commands read from j.par if it is available.  ?TESTAA
\subsection{During the first use}
\label{firstuse}
It is reasonable to have the exe versions and dll's found in
\textbf{J}bin folder in one folder, and to make shortcuts for exe-files
into all working folders. Edit the properties of the shortcut (right click the
shortcut icon) so that the starting directory is the working directory. Or
alternatively you can set the path to the folder containing \textbf{J} executable and
run \textbf{J} in your working directory. Copy also the file j.par into each working
directory.
It is recommended that \textbf{J} is run in the Command Prompt window even if it can be
run also directly from the program shortcut.
Edit first the properties of the I/O window if you are using \textbf{J} directly or from
the Command Prompt window. The properties of the I/O window can be changed by
right-clicking the-icon at the upper left corner. It is reasonable to make the
screen buffer rather large (large height) so that the whole history of the \textbf{J}
session can be seen (this is done in the layout sheet of the shortcut
properties). The default height of the I/O window is also probably too small.
The width should be at least 81. If you would like to use mouse in copy and
paste, put quick edit option on. Also the colours of the text and background of
the \textbf{J} window should be made healthier for eyes (dark text, bright background).
To see that \textbf{J} is running properly, give your first commands at \textcolor{Red}{sit>} prompt:
\textcolor{Red}{sit>}a=7.7;
!
The result should look
a=7.700000
\textcolor{Red}{sit>}
It is possible to use arrow keys to gwt previous command lines.
!
All input lines entered or generated by input programming at \textcolor{Red}{sit>} prompt are
called commands. Commands are either input programming commands (input
commands) or commands that define operations in the \textbf{J} working environment
(operation commands). Input commands and operation commands may read and
interpret more input lines before returning control to the command level.
It is most convenient to develop \textbf{J} applications using include files. There is
available in the jdoc-demo folder an include file jexamples.txt
which can be used to run all examples in this manual. If the include file
is in the working directory you can run any example by wrting the name of the example
in the J-window if you have given '\textcolor{Red}{;incl}(jexamples.txt)' at the \textcolor{Red}{sit>} pronpt.
The working environment of \textbf{J} consists of named objects, temporary objects,
constants, functions, arithmetic operations and text paragraphs. Operation
commands define simple arithmetic operations or more complicated operations on
the data structures. Operation commands are defined using a transformation
language. In addition to operation commands, the same transformation language
is used to define transformation objects which are computed as a group, usually severl times,
and which
can be linked in different ways to data structures or other
transformation objects.
\subsection{Exiting \textbf{J}}
\label{exit}
To exit \textbf{J} program and close console window, just give end command:
\textcolor{Red}{sit>}end
\subsection{Typographical conventions}
\label{typo}
In this manual function names are written in red, option names in blue, object types in
capital letters, object names within the text are written in this color: {Object}.
Names like {ob1} are used as generic names for object and names like  {var1}
are generic names for REAL variables.
If there is no output for an operation command line,
the object Result is used as the default output.
if the line ends with a single semicolon ';' or double semicolon ';;', then
the output may be printed depending MIHIN KOHTAAN
In many cases there is no output object, and a possible
output given is ignored. If an explicit output is necessary, then '=' is
put in front of the function name. Notation ‘[=]’ means that the output can be given but
it is not necessary. In most cases the default output Result is then used:
In some cases no output is then generated (this will be indicated).
For functions that return real values or matrices which can be
used directly in arithmetic or matrix operations,
the existence of output is not indicated.
\subsectione{Subroutines obtained from other sources}
\label{license}
The following subroutines are obtained from other sources.
\begin{itemize}
\item[\textbf{J}]  subroutine tautsp used in j\_function tautspline
from Carl de Boor (1978) A practical guide to splines. Springer, New York, p.310-314
No licence restrictions known
distribution:  http://pages.cs.wisc.edu/$\sim$deboor/pgs/tautsp.f
\item[\textbf{J}]  real function ppvalu used in \textbf{J} function value
from Carl de Boor (1978) A practical guide to splines. Springer, New York, p.310-314
No licence restrictions known
distribution: http://pages.cs.wisc.edu/$\sim$deboor/pgs/tautsp.f
\item[\textbf{J}] subroutine interv , used in function ppvalue
from Carl de Boor (1978) A practical guide to splines. Springer, New York, p.310-314
No licence restrictions known
obtained from: http://pages.cs.wisc.edu/$\sim$deboor/pgs/tautsp.f
Lapack matrix routines
\item[\textbf{J}] Several subroutines from www.netlib.org/lapack
licence : http://www.netlib.org/lapack/LICENSE.txt
\end{itemize}
\section{Command input and output}
\label{cominout}
\textbf{J} has two programming levels. First level, called input programming, generates text lines which are then
transmitted to the interpreter which generates code which is the put into transformations sets or
excuted directly. Input programming loops make it possible to generate large number of command lines
in a compact and short form. This chapter describes input programming concepts and commands.
\subsection{Input record and input line}
\label{inpuline}
\textbf{J} reads input records from the current input channel which may be terminal, file or a text object.
When \textbf{J} interprets input lines, spaces between limiters and function or object names are not
significant. In input programming, functions start with ';' which is part of the function name (and
there can thus be no space immediately after ';'). If a line (record) ends with ',' ,'+', '*´, '-',
'(', '=' or with '>', then the next record is interpreted as a continuation record and
the continuation character is kept as a part of the input
line. If a line ends with '>>', then
the nex line is also continuation line, and  '>>' is ignored. All continuation
records together form one input line. In previous version input programming functions operated on input lines
but now they operate on recors. One input record can contain 4096 characters, and an input line can contain also 4096 characters
(this can be increased if needed).
The continuation line cannot start with ‘*’ or ‘\textcolor{green}{!’\,because\,these\,are\,reserved}
to indicate comments.  Note: '/' (division)cannot be used as last character indicating the continuation of the line because it can
be legal last character indicating the end of an input paragraph.
When entering input lines from the keyboard, the previous lines given from the keyboard can no more be
accessed and edited using the arrow keys owing to MSYS2 MSYS environment used to build the exe-file.
To copy text from the \textbf{J} window into the clipboard right-click the upper left icon, select Edit,
and then select Mark. Next click and drag the cursor to select the text you want to copy and
finally press Enter (or right-click the title bar, select Edit, and in the context menu click Copy).
To paste text from the clipboard into the \textbf{J} command line right-click the title bar, select Edit,
and in the context menu click Paste. Console applications of Intel Fortran do not provide copy
and paste using <cntrl>c and <cntrl>v. An annoying feature of the current command window is that it is possible
All input lines starting with '*' will be comments, and in each line text starting with '!' will also
be interpreted as comment (\textcolor{green}{!debug\,will\,put\,a\,debugging\,mode\,on\,for\,interpretation\,of\,the}
line, but this debug information can be understood only by the author). If a comment line starts
with '*\textcolor{green}{!',\,it\,will\,be\,printed.}
\subsection{Input Paragraph}
\label{inpupara}
Many \textbf{J} functions interpreted and executed at the command level need or can use a group of
text lines as input. In these cases the additional input lines are immediately after the function.
This group of lines is called input paragraph. The input paragraph ends with '/', except the
input paragraph of text function ends with '//' as a text object can contain ordinary input
paragraphs. It may be default for the function that there is input paragraph following. When
it is not a default, then the existence of the input paragraph is indicated with option \textcolor{blue}{in->}
without any value. An input paragraph can contain input programming commands; the
resulting text lines are transmitted to the \textbf{J} function which interprets the input paragraph
\begin{example}[inpuparag]Example of inputparagraph\\
\label{inpuparag}
tr=\textcolor{VioletRed}{trans}()\\
a=\textcolor{VioletRed}{log}(b)\\
\textcolor{VioletRed}{write}(\$,'($\sim$sinlog\,is=$\sim$,f4.0)',\textcolor{VioletRed}{sin}(a))\\
/\\
b=\textcolor{VioletRed}{matrix}(2,3,\textcolor{blue}{in->})\\
1,2,3\\
5,6,7\\
/
\end{example}
\subsection{Command shortcuts}
\label{short}
Command shortcuts are defined by defining character variables. When entering the
name of a character variable at \textcolor{Red}{sit>} prompt or from an include file, \textbf{J} excutes the command.
The command can be either input programming command or ??? command. The file jexamples.inc
shows an useful way to organize shortcuts and include files.
\begin{example}[shortex]Example of using shortcuts and include files\\
\label{shortex}
short1='\textcolor{VioletRed}{sin}(Pi)+\textcolor{VioletRed}{cos}(Pi);'\\
short1\\
te=\textcolor{VioletRed}{text}()\\
this=\textcolor{VioletRed}{thisfile}()\\
ju1='\textcolor{Red}{;incl}(this,\textcolor{blue}{from->}$\sim$a1$\sim$)'\\
ju2='\textcolor{Red}{;incl}(this,\textcolor{blue}{from->}$\sim$a2$\sim$)'\\
\textcolor{Red}{;return}\\
;a1:\\
'greetings from a1'\\
\textcolor{Red}{;return}\\
;a2:\\
'here, jump to a1';\\
ju1\\
'back here, return to \textcolor{Red}{sit>}'\\
\textcolor{Red}{;return}\\
//\\
\textcolor{VioletRed}{write}('shortex.txt',\$,te)\\
\textcolor{Red}{;incl}('shortex.txt')\\
ju1\\
ju2\\
delete\_f('shortext.txt')\\
te=0 \textcolor{green}{!delete\,also\,text\,object\,te}
\end{example}
\subsection{Input programming}
\label{inpuprog}
The purpose of the input programming is to read or generate \textbf{J} commands or input lines
needed by \textbf{J} functions. The names of input programming commands start with semicolon ';'.
There can be no space between ';' and the following input programming function. The syntax
of input programming commands is the same as in \textbf{J} functions, but the input programming
functions cannot have an output. There are also controls structures in the input programming.
An input paragraph can contain input programming structures.
\subsubsection{Addresses in input programming}
\label{inpuad}
The included text files can contain addresses. Addresses define possible starting points for the
inclusion or jump addresses within an include file. An address starts with semicolon (;) and
ends with colon (:). There cannot be other text but not commands on the address line.
\\
;ad1:  At this point we are doing thit and that
\\
\begin{note}
The definition of a transformations object can also contain addresses. These addresses start
with a letter and end also with colon (:). When defining a transformation object with \textcolor{VioletRed}{trans}() function,
the input paragraph can contain input programming addresses and code addresses. It is up to
input programming what code addresses become part of the transformation object.
\end{note}
\subsubsection{Changing “i” sequences}
\label{inpureplace}
If an original input line contains text within quotation marks, then the sequence will be replaced
as follows. If a character variable is enclosed, then the value of the character variable is
substituted: E.g.
directory='D:$\backslash$j$\backslash$'
name='area1'
extension='svs'
then
\textcolor{blue}{in->}'"directory""name"."extension"'
is equivalent to
\textcolor{blue}{in->}'D:$\backslash$j$\backslash$area1.svs'
If the "-expression is not a character variable then \textbf{J} interprets the sequence as an arithmetic
expression and computes its value. Then the value is converted to character string and
substituted into the place. E.g. if nper is variable having value 10, then lines
\color{Green}
\begin{verbatim}
x#"nper+1"#"nper" = 56
chv = 'code"nper"'
\end{verbatim}
\color{Black}
are translated into
\color{Green}
\begin{verbatim}
x#11#10 = 56
chv = 'code10'
\end{verbatim}
\color{Black}
With " " substitution one can define general macros which will get specific interpretation by
giving values for character and numeric parameters, and numeric parameters can be utilized in
variable names or other character strings. In transformation sets one can shorten computation
time by calculating values of expressions in the interpretation time instead of doing
computations repeatedly. E.g. if there is in a data set transformation
x3 = "\textcolor{VioletRed}{sin}(Pi/4)"*x5
Then evaluation of \textcolor{VioletRed}{sin}(Pi/4) is done immediately, and the value is transmitted to the
transformation set as a real constant.
If value of the expression within a “” sequence is an integer then the value is dropped in the
place without the decimal point and without any spaces, otherwise its value is presented in
form which is dependent on magnitude of the value. After J3.0 the format can be explicitly
specified within [] before the numeric value. Eg. text can be put into a figure as
fig =
\textcolor{VioletRed}{drawline}(5,5,\textcolor{blue}{mark->}’y=”[f5.2]coef(reg,x1)“*x1+”[f5.2]coef(reg,1)“‘)
See file jex.txt and Chapter 8 for an ex
\subsubsection{\textcolor{Red}{;incl}()}\index{;incl}
\label{incl}
Includes lines from a file or from a text object. Using the \textcolor{blue}{from->}
option the include file can contain sections which start with adresses like
;ad: \\
and end with \\
\textcolor{Red}{;return}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args  \tabto{3cm}  0|1  \tabto{5cm}   Ch|Tx  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent   file name. Default: the same file is used as in the previous \textcolor{Red}{;incl}().he
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{from}  \tabto{3cm}  N|1  \tabto{5cm}   Ch  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent gives the starting \textcolor{blue}{in->} address for the inclusion, address is given without starting ';'
and ending ':'.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{wait} \tabto{3cm}  N|0  \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  \textbf{J} waits until the include file can be opened. Useful in client server applications.
See chapter \textbf{J} as a server.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
Include files can be nested up to 4 levels.evels
\end{note}
\begin{note}
See Chapter Defining a text object with text function and using it in \textcolor{Red}{;incl} how to include
commands from a text object.
\end{note}
\begin{note}
When editing the include file with Notepad ++, it is reasonable to set the language as Fortran (free form).
\end{note}
\begin{example}[inpuincl]Example of \textcolor{Red}{;incl}()\\
\label{inpuincl}
\textcolor{Red}{;incl}('file.txt')\\
\textcolor{Red}{;incl}('file2.txt',\textcolor{blue}{from->}'ad1')\\
\textcolor{Red}{;incl}(\textcolor{blue}{from->}'ad2')
\end{example}
\begin{note}
Using \textcolor{Red}{;incl}() in a project
When working in a project it is reasonable to organize
the include file as follows. Put into the beginning of the file section:\\
this=\textcolor{VioletRed}{thisfile}() \,\textcolor{green}{!There\,can\,different\,versions\,of\,the\,file\,with\,differetn\,names.\\}
A='\textcolor{Red}{;incl}(this)' \textcolor{green}{!If\,new\,sections\,are\,added\,to\,the\,file,\,new\,shortcuts}
can be defined by adding those here and writing A at \textcolor{Red}{sit>} prompt.\\
R='\textcolor{Red}{;incl}(this,\textcolor{blue}{from->}$\sim$read$\sim$)' \,\,\,\,\textcolor{green}{!\,read\,data\,in\,\\}
T1='\textcolor{Red}{;incl}(this,\textcolor{blue}{from->}$\sim$task1$\sim$)' \,\,\textcolor{green}{!\,first\,analysis\,\\}
T2='\textcolor{Red}{;incl}(this,\textcolor{blue}{from->}$\sim$task2$\sim$)' \,\,\textcolor{green}{!\,second\,analysis\,\\}
\textcolor{Red}{;return} \\
Now everything what needs to written at \textcolor{Red}{sit>} after the first
\textcolor{Red}{;incl}() are the shortcuts. If adding section task3 then
add the shortcut here, then write shortcuts A and T3 at \textcolor{Red}{sit>}.
The file jexamples.inc which comes with the manual and which is generated
with the jmanual program shows an examle.
\end{note}
\begin{note}
The adress line can contain comment starting with '!'.
\end{note}
\subsubsection{\textcolor{Red}{;goto}()}\index{;goto}
\label{inpugoto}
Go to different adress in \textcolor{Red}{;incl}() file.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 1 \tabto{5cm}  CHAR \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The address from which the reading continues. With \textcolor{Red}{;goto}('adr1')
the adress line starts ;adr1:
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[inpugotoex]Example of \textcolor{Red}{;goto}() and \textcolor{Red}{;incl}()\\
\label{inpugotoex}
\textcolor{VioletRed}{write}('goto.txt','c','\textcolor{VioletRed}{print}($\sim$Start\,jumping$\sim$)')\\
\textcolor{VioletRed}{write}('goto.txt','c','\textcolor{Red}{;goto}($\sim$ad2$\sim$)')\\
\textcolor{VioletRed}{write}('goto.txt','c',';ad1:')\\
\textcolor{VioletRed}{write}('goto.txt','c','\textcolor{VioletRed}{print}($\sim$Greetings\,from\,ad1$\sim$)')\\
\textcolor{VioletRed}{write}('goto.txt','c','\textcolor{Red}{;return}')\\
\textcolor{VioletRed}{write}('goto.txt','c',';ad2:')\\
\textcolor{VioletRed}{write}('goto.txt','c','\textcolor{VioletRed}{print}($\sim$Greetings\,from\,ad2$\sim$)')\\
\textcolor{VioletRed}{write}('goto.txt','c','\textcolor{Red}{;goto}($\sim$ad1$\sim$)')\\
\textcolor{VioletRed}{close}('goto.txt')\\
\textcolor{Red}{;incl}('goto.txt',\textcolor{blue}{print->})\\
\textcolor{Red}{;incl}('goto.txt')\\
\textcolor{Red}{;incl}('goto.txt',\textcolor{blue}{from->}'ad1',\textcolor{blue}{print->})\\
delete('goto.txt')
\end{example}
\subsubsection{\textcolor{Red}{;return} returns from include file}\index{;return}
\label{inpureturn}
\textcolor{Red}{;return} in an input file means that the control returns to the point where a
jumpt to an address was found. Two different cases need to be separated:
\begin{itemize}
\item[\textbf{J}] The conrol came to the starting address or to the beginning of the include file
from outside the current include file using a \textcolor{Red}{;incl} command. Then \textcolor{Red}{;return} returns the control to upper level include
file or to the \textcolor{Red}{sit>} prompt.
\item[\textbf{J}] The control came to the starting address from within the same include file using
either an explicit \textcolor{Red}{;incl} or \textcolor{Red}{;goto} command or generating these commands commands
with command shortcut.
\end{itemize}
\subsubsection{\textcolor{Red}{;do}()}\index{;do}
\label{inpudo}
Generates new input records and replaces text with other text
using " "  to generate numbers, @list to generate lists of object names
and @\textcolor{VioletRed}{list}(elem) to pick the names of the elements of a list, or
\textcolor{Red}{;sum}() to generate sums and \textcolor{Red}{;dif}() to generate differences.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 3|4 \tabto{5cm}  Var,Num.. \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Arguments are: iteration index, starting limit,
final limit and step. First argument must be a variable name and others
can be REAL variables or numeric constants.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[inpudoex]Examples of \textcolor{Red}{;do}()\\
\label{inpudoex}
\textcolor{Red}{;do}(i,1,2)\\
x"i"="i"*10\\
\textcolor{VioletRed}{print}('Greetings from iteration "i"')\\
\textcolor{Red}{;enddo}\\
\textcolor{VioletRed}{print}(x1,x2)
\color{Green}
\begin{verbatim}
!After dropping out extra text about the processing we get:
<print('Greetings from iteration 1')
'Greetings from iteration 1'
<print('Greetings from iteration 2')
'Greetings from iteration 2'
sit< print(x1,x2)
<print(x1,x2)
x1=   10.000000000000000
x2=   20.000000000000000
\end{verbatim}
\color{Black}
\end{example}
\subsubsection{\textcolor{Red}{;sum}()}\index{;sum}
\label{inpusum}
\textbf{J} can generate text of form part1+part2+...partn into input line using
input programming function ;isum(). The syntax of the function is as follows:\\
\textcolor{Red}{;sum}(i,low,up,step)(text)\\
or \\
\textcolor{Red}{;sum}(i,low,up)\\
Arguments low, up and step must be integers (actually from nonintger values, the
integer part is used) or REAL variables. Thus te valuse cannot be obtained
from arithmetic operations. Sum is useful at least in \textcolor{VioletRed}{problem}() function.
\begin{example}[inpusumex]Example of \textcolor{Red}{;sum}()\\
\label{inpusumex}
su='\textcolor{Red}{;sum}(i,1,5)(a"i"*x")'\\
\textcolor{VioletRed}{print}(su)
\color{Green}
\begin{verbatim}
<print(su)
'a1*x1+a2*x2+a3*x3+a4*x4'
\end{verbatim}
\color{Black}
prob=\textcolor{VioletRed}{problem}()\\
\textcolor{Red}{;sum}(i,1,5)(a"i"*x"i")==max
\color{Green}
\begin{verbatim}
<prob=problem()
prob< a1*x1+a2*x2+a3*x3+a4*x4+a5*x5==max
\end{verbatim}
\color{Black}
\end{example}
\begin{note}
\textcolor{Red}{;dif}()() works similarly for minus
\end{note}
\subsubsection{\textcolor{Red}{;dif}()}\index{;dif}
\label{inpudif}
\textbf{J} can generate text of form part1-part2-...partn into input line using
input programming function \textcolor{Red}{;dif}(). The syntax of the function is as follows:\\
\textcolor{Red}{;dif}(i,low,up,step)(text)\\
or \\
\textcolor{Red}{;dif}(i,low,up)\\
Arguments low, up and step must be integers (actually from nonintger values, the
integer part is used) or REAL variables. Thus te valuse cannot be obtained
from arithmetic operations. \textcolor{Red}{;dif}() is useful at least in \textcolor{VioletRed}{problem}() function.
\begin{note}
\textcolor{Red}{;sum}()() works similarly for plus. See \textcolor{Red}{;sum}() for examples.
\end{note}
\subsubsection{\textcolor{Red}{;pause}}\index{;pause}
\label{inpupause}
Including input from an include file can be interrupted using an input programming
command \textcolor{Red}{;pause} promt or the \textbf{J} function \textcolor{VioletRed}{pause}('<prompt>'). In both cases
the user can give \textbf{J} commands, e.g., print objects, change the value of Printdebug etc.
The difference is that  \textcolor{VioletRed}{pause}('<prompt>') goes first through the interpreted and the interptreted
code is transmitted to the \textbf{J} function driver. In the \textcolor{Red}{;pause}- pause it is possible to
use input programming commands while in \textcolor{VioletRed}{pause}()- pause it is not possible. In both cases, when
an error occurs, the control remains at the pause prompt. If the user is pressing
<return> \textbf{J} continues in the include file. If \textcolor{VioletRed}{pause}() is part of a transformation object,
pressing <return>, the function driver continues in the transformation object.
If the user gives command 'e' or 'end', then \textbf{J} procees similarly as if an error had occured,
i.e. print error messages and returns control to \textcolor{Red}{sit>} -promt.
\subsubsection{\textcolor{Red}{;return} returns from include file}\index{;return}
\label{inpureturn}
\textcolor{Red}{;return} in an input file means that the control returns to the point where a
jumpt to an address was found. Two different cases need to be separated:
\begin{itemize}
\item[\textbf{J}] The conrol came to the starting address or to the beginning of the include file
from outside the current include file using a \textcolor{Red}{;incl} command. Then \textcolor{Red}{;return} returns the control to upper level include
file or to the \textcolor{Red}{sit>} prompt.
\item[\textbf{J}] The control came to the starting address from within the same include file using
either an explicit \textcolor{Red}{;incl} or \textcolor{Red}{;goto} command or generating these commands commands
with command shortcut.
\end{itemize}
\subsection{Generating sequences with ... -construct}
\label{dots}
It is often natural to index object names, and often we need to refer object
names having consecutive index numbers or index letters. In \textbf{J} versions before version 3.0 it
was possible to generate object lists using ... -construct which replaced part of
the input line with the names of objects being between the the object
name before ... and after ... . Now the dots construct is no more done as
part of the input programming but in the interpret subroutine which interprets the
input line and generates the integer vector for function and argument indices.
But as dots work as if it would be part of the input programming, it is presented in this
section. Currently also sequences of integer constants can be generated with dots and
sequences can be from larger to smaller.
\begin{example}[dotsex]Example of dots construct\\
\label{dotsex}
dat=\textcolor{VioletRed}{data}(\textcolor{blue}{read->}(x4...x7),\textcolor{blue}{in->})\\
1,2,3,4\\
11,12,13,14\\
/\\
\textcolor{VioletRed}{stat}(\textcolor{blue}{min->},\textcolor{blue}{max->},\textcolor{blue}{mean->})\\
x3\%mean...x7\%mean;\\
A...D=4...1;\\
Continue=1 \,\textcolor{green}{!demo\,of\,error\,in\,\textcolor{VioletRed}{data}()}\\
dat=\textcolor{VioletRed}{data}(\textcolor{blue}{read->}(x3...x7),\textcolor{blue}{in->})\\
1,2,3,4\\
11,12,13,14\\
/\\
Continue=0
\end{example}
\section{\textbf{J} functions: an overview}
\label{jfuncs}
\textbf{J} functions are organized into 21 groups. Some of of the functions are such that the
interpreter converts the code given by the user into new function names. For instance
the code 1+2 is first changed into \textcolor{VioletRed}{PLUS}(1,2), and code a(3) is changed
into form \textcolor{VioletRed}{getelem}(a,3). The following list contains also such implicit
function names to support also those users who are interested to start looking at
the open source code.
The ordering of functions in this manual is the same as in the file jmodules.f90
in order to make it easier to start looking the source code, even if the order is
not the most logical from the application point of view. When adding new functions into
any group is easy when the new function is put to the end of group so new functions are not inserted
in the middle of group even if it would more logical.
!
\begin{itemize}
\item Special functions
\begin{itemize}
\item setoption
\item getelem
\item setelem
\item list2
\item o1\_funcs
\item o2\_funcs
\item o3\_funcs
\item setcodeopt
\end{itemize}
\item  Objects
\begin{itemize}
\item type
\item delete\_o
\item exist\_o
\item name
\end{itemize}
\item 	Transformations
\begin{itemize}
\item trans
\item call
\item pause
\item noptions
\item R
\end{itemize}
\item  Loops and controls structures
\begin{itemize}
\item do
\item if
\item ASSIGN
\item sit
\item which
\item errexit
\item goto
\item itrace
\item trace
\item tracenow
\item itraceoff
\item traceoff
\item tracetest
\item assone
\item enddo
\item assmany
\item goto2
\item goto3
\end{itemize}
\item Arithmetic and logical operations after converting to the polish notation
\begin{itemize}
\item HMULT
\item HDIV
\item IPOWER
\item MULT
\item DIV
\item PLUS
\item MINUS
\item EQ
\item NE
\item LE
\item LT
\item GE
\item GT
\item NOT
\item AND
\item OR
\item EQV
\item NEQV
\item POWER
\end{itemize}
\item Arithemetic functions which can operate on scalars or on matrices
\begin{itemize}
\item max
\item sign
\item mod
\item nint
\item int
\item ceiling
\item floor
\item sqrt
\item sqrt2
\item log10
\item exp
\item sin
\item sind argument is in degrees, also in the following
\item cos
\item cosd
\item tan
\item tand
\item cotan
\item cotand
\item asin
\item asind
\item acos
\item acosd
\item atan
\item atand
\item acotan
\item acotand
\item sinh
\item cosh
\item tanh
\item fraction
\item abs
\end{itemize}
\item  Special arithemetic functions
\begin{itemize}
\item der
\item gamma
\item loggamma
\item logistic
\item npv
\end{itemize}
\item  Probability distributions
\begin{itemize}
\item pdf
\item cdf
\item bin
\item negbin
\item density
\end{itemize}
\item Random numbers
\begin{itemize}
\item ran
\item rann
\item ranpoi
\item ranbin
\item rannegbin
\item select
\item random
\end{itemize}
\item Interpolation
\begin{itemize}
\item interpolate
\item plane
\item bilin
\end{itemize}
\item  List functions
\begin{itemize}
\item  list
\item merge
\item difference
\item index
\item index\_v
\item len
\item ilist
\item putlist
\end{itemize}
\item  Creating a text  object
\begin{itemize}
\item text
\item txt
\end{itemize}
\item File handling
\begin{itemize}
\item exist\_f
\item delete\_f
\item close
\item showdir
\item setdir
\item thisfile
\item filestat
\item read
\item write
\item print
\item ask
\item askc
\item printresult
\item printresult2
\end{itemize}
\item  Matrices
\begin{itemize}
\item matrix
\item nrows
\item ncols
\item t
\item inverse
\item solve
\item qr
\item eigen
\item sort
\item envelope
\item ind
\item mean
\item sum
\item var
\item sd
\item minloc
\item maxloc
\item cumsum
\item corrmatrix
\end{itemize}
\item  Data functions
\begin{itemize}
\item data
\item newdata
\item exceldata
\item linkdata
\item getobs
\item nobs
\item classvector
\item values
\item transdata
\end{itemize}
\item  Statistical functions
\begin{itemize}
\item stat
\item cov
\item corr
\item regr
\item mse
\item rmse
\item coef
\item r2
\item se
\item nonlin
\item varcomp
\item classify
\item class
\end{itemize}
\item  Linear programming
\begin{itemize}
\item problem
\item jlp
\item weights
\item unit
\item schedcum
\item schedw
\item weight
\item partweights
\item partunit
\item partschedcum
\item partschedw
\item partweight
\item priceunit
\item weightschedcum
\item priceschedcum
\item priceschedw
\item weightschedw
\item integerschedw
\item xkf
\end{itemize}
\item Plotting figures
\begin{itemize}
\item plotyx
\item draw
\item drawclass
\item drawline
\item show
\item plot3d
\end{itemize}
\item Splines, stem splines,  and volume functions
\begin{itemize}
\item tautspline
\item stemspline
\item stempolar
\item laasvol
\item laaspoly
\item integrate
\end{itemize}
\item Bit functions
\begin{itemize}
\item setbits
\item clearbits
\item getbit
\item getbitch
\item bitmatrix
\item setvalue
\item closures
\end{itemize}
\item  Misc. utility functions
\begin{itemize}
\item value
\item properties
\item cpu
\item seconds
\end{itemize}
\end{itemize}
\section{Special functions}
\label{special}
The special functions are such that the interpreter uses these functions for special operations.
Only \textcolor{VioletRed}{list2}() is function which also the user can use, but the interpreter is
is using it implicitly.
\subsection{\textcolor{VioletRed}{setoption}(): set option on}\index{setoption()}
\label{setoption}
When a function has an option then the interpreter generates first code
\textcolor{VioletRed}{setoption}(...) where the arguments of the option are interpred in the similar way as
arguments of all functions. Then the interpreter genarates the code for
\textcolor{VioletRed}{setoption}() function in a special way.
\subsection{Get or set a matrix element or submratrix}
\label{getelem}
Matrix elements or submatrices can be accessed using the same syntax as
accesing \textbf{J} functions.
One can get or set matrix elements and submatrices as follows. If the expression
is on the right side of '=' then \textbf{J} gets a REAL value or submatrix, if the expression
is on the left side of '=', the \textbf{J} sets new values for a matrix element or a submatrix.
In the following formulas \textcolor{teal}{C} is a column vector, \textcolor{teal}{R} a row vector, and \textcolor{teal}{M} is
a general matrix with m rows and n columns.
If \textcolor{teal}{C} is actually REAL it can
be used as if it would 1 x 1 MATRIX. This can be useful when working with
matrices whose dimensions can vary starting from 1 x 1. Symbol \textcolor{teal}{r} refers to
row index, \textcolor{teal}{r1} to first row in a row range, \textcolor{teal}{r2} to the last row. The rows and
columns can be specifiel using ILIST objects \textcolor{teal}{il1} and \textcolor{teal}{il2} to specify noncontiguous ranges.
It is currently not possible to mix ILIST range and contiguous range, so if ILIST
is needed for rows (columns), it must be used also for columns (rows). ILIST can be
sepcified using explicitly \textcolor{VioletRed}{ilist}() function or using {} construction.
Similarly columns are indicated  with \textcolor{teal}{c}. It is always legal to refer to
vectors by using the \textcolor{teal}{M} formulation and giving \textcolor{teal}{c} with value 1 for column vectors and
and \textcolor{teal}{r} with value 1 for row vectors.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 0-4 \tabto{5cm}  REAL | ILIST \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent row and column range as explained below.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{diag} \tabto{3cm} N| \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Get or set diagonal elements
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{sum} \tabto{3cm} N|0|1 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  When setting elements, the right side is added to the current elements. If the
\textcolor{blue}{sum->} option has argument, the right side is multiplied with the argument when adding to the curretn elements.
\end {changemargin}
\hline
\vspace{0.2cm}
Row and column ranges can be spcidie as follows.
\begin{itemize}
\item[\textbf{J}\.] \textcolor{teal}{M}(r,c) \tabto{5cm} Get or set single element.
\item[\textbf{J}\.] \textcolor{teal}{C}(r)  \tabto{5cm} Get or set single element in column vector.
\item[\textbf{J}\.] \textcolor{teal}{R}(c) \tabto{5cm} Get or set single element in column vector.
\item[\textbf{J}\.] \textcolor{teal}{M}(RANGES) \tabto{5cm} Get or set a submatrix, where RANGES
can be. For a column vector, the column range need not to specified.
\begin{itemize}
\item[\textbf{J}\.] r1,-r2,c1,-c2
\item[\textbf{J}\.] r,c1,-c2  \tabto{5cm} part of row r
\item[\textbf{J}\.] r1,-r2,c	\tabto{5cm} part of column c
\item[\textbf{J}\.] r1,-r2,All  \tabto{5cm} All columns of the row range
\item[\textbf{J}\.] All,c1,-c2  \tabto{5cm} All rows of the column range
\item[\textbf{J}\.] {r1,....rm},{c1,...,cn}  \tabto{5cm} Given rows and columns
\item[\textbf{J}\.] {r1,....rm}  \tabto{5cm} Given rows for column vector
\item[\textbf{J}\.] il1,il2   \tabto{5cm} for matrix with several columns
\item[\textbf{J}\.] il1   \tabto{5cm} for column vector
\end{itemize}
\item[\textbf{J}\.] When r2= m, then -r2 can be replaced with \textcolor{teal}{Tolast}.
\item[\textbf{J}\.] When c2= n, then -c2 can be replaced with \textcolor{teal}{Tolast}.
\end{itemize}
If option \textcolor{blue}{diag->} is present then
\begin{itemize}
\item[\textbf{J}\.] \textcolor{teal}{M}(\textcolor{blue}{diag->}) Get or set the diagonal. If \textcolor{teal}{M} is not square matrix, and error
occurs.
\item[\textbf{J}\.] \textcolor{teal}{M}(r1,-r2,\textcolor{blue}{diag->}) (Again -r2 can be \textcolor{teal}{Tolast}.
\end{itemize}
\begin{note}
Note
When setting values to a submatrix the the the values given in input matrix
are put into the outputmatrix in row order, and the shape of the input and output matrices need
not be the same. An error occurs only if input and output contain different number of
elements.
\end{note}
\begin{example}[getset]Get or set submatrices\\
\label{getset}
A=\textcolor{VioletRed}{matrix}(3,4,\textcolor{blue}{do->});\\
B=A(1,-2,3,-4);\\
A(1,-2,3,-4)=B+3;\\
A(1,-2,3,-4,\textcolor{blue}{sum->})=-5;\\
A(1,-2,3,-4,\textcolor{blue}{sum->}2)=A(2,-3,1,-2,\textcolor{blue}{sum->}2);\\
C=A({1,3},{4...2});\\
H=\textcolor{VioletRed}{matrix}(4,4,\textcolor{blue}{diag->},\textcolor{blue}{do->}3);\\
H(3,-4,\textcolor{blue}{diag->})=\textcolor{VioletRed}{matrix}(2,\textcolor{blue}{values->}(4,7));
\end{example}
\begin{note}
When giving range, the lower and upper limit can be equal.qual
\end{note}
\subsection{\textcolor{VioletRed}{setelem}(): Putting something  into an object.}\index{setelem()}
\label{setelem}
The origin of this function is the function which was used in previous versions
to set an matrix element, which explains the name. Now it is used to replace values
of submatrices when submatrix expression is on the
output side (e.g. a(1,-3,All)=..).
\begin{note}
If someone starts to use the own function property of the open source J, she/he
probably would like to get the possiblity to put information into from her/his object types
also. To implement this property requires some co-operation from my side.
\end{note}
\begin{note}
In effect the \textcolor{VioletRed}{getelem}() and \textcolor{VioletRed}{setelem}() functions are excuted in the same
\textcolor{VioletRed}{getelem}() subroutine, because bot functions can utilize the same code.
\end{note}
\subsection{\textcolor{VioletRed}{list2}()}\index{list2()}
\label{list20}
The interpreted utilizes this to separate when spearating output and input objects.
See Section \ref{list2} hw user can use this function
\subsection{setcode(): Initialization of a code option}
\label{setcode}
This function initializes an code option for a function which has the option.
\section{Functions for handling objects}
\label{objects}
The following functions can handle objects.
\subsection{Deleting objects: delete\_o()}
\label{delete}
When an object with a given name is created, the name cannot be removed. With
delete\_0() function one can free all memory allocated for data structures needed
by general objects:
delete\_o(obj1,…,objn)
After deleting an object, the name refers to a real variable (which is
initialized by the delete\_o() function into zero).
\begin{note}
Other objects except matrices can equivalently be deleted by giving
command
obj1,…,objn = 0
This is because the output objects of any functions are first deleted before
defining them anew. Usually an object is automatically deleted if the object
name is as an output object for other functions.
\end{note}
\begin{note}
One can see how much memory each object is using \textcolor{VioletRed}{print}(Names).mes
\end{note}
\begin{note}
Deleting a compound object deletes also such
subobjects which have no meaning when the main object is deleted. But e.g. if a
data object is deleted then the as-sociated transformation object is not
deleted as the transformation can be used independently.
\end{note}
\begin{note}
Files can be deleted with delete\_f(file). See IO-functions for
details.
\end{note}
\begin{note}
If the user has defined own new compound objects in the open source
\textbf{J} software she/he needs to define the associated delete function.
\end{note}
\subsection{_o exist\_o(): does an object exist}
\label{exist}
looks whether an object with the name given in
the character constant  argument exists.
\begin{note}
In the prvious versions of \textbf{J} same function was used for files and objects.
\end{note}
\subsection{\textcolor{VioletRed}{name}(): writes the name of an object}\index{name()}
\label{name}
The argument gives the index of the object. This function
may useful if \textbf{J} prints in problem cases the object indices.
\subsection{Generating a transformation object \textcolor{VioletRed}{trans}()}\index{trans()}
\label{trans}
\textcolor{VioletRed}{trans}() function interprets lines from input paragraph following the \textcolor{VioletRed}{trans}() command and puts the
interpreted code into an integer vector, which can be excuted in several places.
If there are no arguments in the function, the all objected used within the
transforamations are global. This may cause conflicts if there are several recursive
functions operating at the same time with same objects. \textbf{J} checks some of
these conflict situations, but not all.  These conflicts can be avoided by giving
intended global arguments  in the list of arguments.
Then an object 'ob' created e.g. with transformation object \textcolor{teal}{tr} have prefix
]tr$\backslash$[ yelding ]tr$\backslash$ob[. Actually also these objects are global, but their prefix
protects them so that they do not intervene with objects having the same name in the
calling transformation objec.
Each line in the input paragraph is read and interpreted and packed into a transformation
object, and associated tr\%input and tr\%output lists are created for input and output
variables. Objects can be in both lists. Objects having names starting
with '\$' are not put into the input or output lists. The source code is saved in a text object
tr\%source. List tr\%arg contains all arguments.
!
If a semicolon ';'  is at the end of an input line, then
the output is printed if REAL variable Prindebug has value 1 or value>2 at
the execution time. If the double semicolon ';;' is at the end then the output is
printed if Printresult>1. If there is no output, but just list of objects, then these
objects will be printed with semicolns.
!
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 1 \tabto{5cm}  Data \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The TRANS object generated.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} N|1- \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Global objects.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
Options \textcolor{blue}{input->}, \textcolor{blue}{local->}, \textcolor{blue}{matrix->}, \textcolor{blue}{arg->}, \textcolor{blue}{result->}, \textcolor{blue}{source->} of previous
versions are obsolte.
\end{note}
\begin{note}
The user can intervene the execution from console if the code calls \textcolor{VioletRed}{read}(\$,),
\textcolor{VioletRed}{ask}(), \textcolor{VioletRed}{askc}() or \textcolor{VioletRed}{pause}() functions. During the pause one can give any command excepts
such input programming command as \textcolor{Red}{;incl}.
\end{note}
\begin{note}
The value of Printresult can be changed in other parts of the transformation, or
in other transforamations called or during execution of \textcolor{VioletRed}{pause}().
\end{note}
\begin{note}
Output variables in \textcolor{blue}{maketrans->} transformations whose name start with \$ are not put into the new data object.
\end{note}
\begin{example}[transex]Demonstrates also error handling\\
\label{transex}
tr=\textcolor{VioletRed}{trans}()\\
\$x3=x1+3\\
x2=2/\$x3;\\
/\\
tr\%input,tr\%output,tr\%source;\\
x1=8\\
\textcolor{VioletRed}{call}(tr)\\
tr2=\textcolor{VioletRed}{trans}(x1,x2)\\
\$x3=x1+3\\
x2=2/\$x3;\\
x3=x1+x2+\$x3;\\
/\\
tr2\%input,tr2\%output,tr2\%source;\\
\textcolor{VioletRed}{call}(tr2)\\
tr2\x3; \,\,\textcolor{green}{!x3\,is\,now\,local}\\
tr3=\textcolor{VioletRed}{trans}()\\
x1=-3\\
\textcolor{VioletRed}{call}(tr) \textcolor{green}{!this\,is\,causing\,division\,by\,zero}\\
/\\
Continue=1 \,\,\textcolor{green}{!\,continue\,after\,error}\\
\textcolor{VioletRed}{call}(tr3)
\end{example}
\color{Green}
\begin{verbatim}
sit>transex
<;incl(exfile,from->'transex')
<tr=trans()
<$x3=x1+3
<x2=2/$x3;
</
<tr%input,tr%output,tr%source;
tr%input is list with            2  elements:
x1 $x3
tr%output is list with            1  elements:
x2
tr%source is text object:
1 $x3=x1+3
2 x2=2/$x3;
3 /
///end of text object
<x1=8
<call(tr)
x2=0.18181818
<tr2=trans(x1,x2)
<$x3=x1+3
<x2=2/$x3;
<x3=x1+x2+$x3;
</
<tr2%input,tr2%output,tr2%source;
tr2%input is list with            1  elements:
x1
tr2%output is list with            1  elements:
x2
tr2%source is text object:
1 $x3=x1+3
2 x2=2/$x3;
3 x3=x1+x2+$x3;
4 /
///end of text object
<call(tr2)
x2=0.18181818
tr2\x3=19.1818181
<tr2\x3;
tr2\x3=19.1818181
<tr3=trans()
<x1=-3
<call(tr)
</
<Continue=1
<call(tr3)
*division by zero
*****error on row            2  in tr%source
x2=2/$x3;
recursion level set to    3.0000000000000000
*****error on row            2  in tr3%source
call(tr)
recursion level set to    2.0000000000000000
*err* transformation set=$Cursor$
recursion level set to    1.0000000000000000
****cleaned input
call(tr3)
*Continue even if error has occured
<;return
\end{verbatim}
\color{Black}
\subsection{Excuting transformation object explicitly \textcolor{VioletRed}{call}()}\index{call()}
\label{call}
Interpreted transformations in a transformation object can be automatically executed by other \textbf{J}
functions or they can be executed explicitly using \textcolor{VioletRed}{call}() function.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Arg \tabto{3cm} 1 \tabto{5cm}  TRANS \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The transformation object executed.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
A transformation objects can be used recursively, i.e. a transformation can be called from
itself. The depth of recursion is not controlled by J, so going too deep in recursion will
eventually lead to a system error.
\end{note}
\begin{example}[recursion]Recursion produces system crash.\\
\label{recursion}
tr=\textcolor{VioletRed}{trans}() \textcolor{green}{!level\,will\,be\,initialized\,as\,zero}\\
level;\\
level=level+1\\
\textcolor{VioletRed}{call}(tr)\\
/
\end{example}
\section{\textcolor{VioletRed}{do}() loops}\index{do()}
\label{loops}
The loop construction in \textbf{J} looks as follows:
\\
\textcolor{VioletRed}{do}(i,start,end[,step])
\\
enddo
\\
\begin{note}
cycle and exit are implemented in the current \textbf{J} version with \textcolor{VioletRed}{goto}()oto
Within a do–loop there can be cycleand exitdostatements
\end{note}
\begin{note}
There can be 8 nested loops. do-loop is not allowed at command level.evel
\end{note}
\begin{example}[doex]do-loop\\
\label{doex}
tr=\textcolor{VioletRed}{trans}()\\
\textcolor{VioletRed}{do}(i,1,5)\\
ad1: \textcolor{VioletRed}{if}(i.eq.3)\textcolor{VioletRed}{goto}(cycle)\\
i;\\
\textcolor{VioletRed}{if}(i.eq.4)\textcolor{VioletRed}{goto}(jump)\\
cycle:enddo\\
jump:i;\\
\textcolor{VioletRed}{goto}(ad1) \,\textcolor{green}{!\,it\,is\,not\,allowed\,to\,jump\,into\,a\,loop}\\
/\\
\textcolor{VioletRed}{call}(tr)
\end{example}
\subsection{\textcolor{VioletRed}{if}()}\index{if()}
\label{if}
\textcolor{VioletRed}{if}()j\_statement… \newline
The one line if-statement.
\subsection{\textcolor{VioletRed}{errexit}()}\index{errexit()}
\label{errexit}
Function \textcolor{VioletRed}{errexit}() returns the control to \textcolor{Red}{sit>} prompt with a message similarly
as when an error occurs.
\begin{example}[errexitex]itex\\
\label{errexitex}
tr=\textcolor{VioletRed}{trans}()\\
\textcolor{VioletRed}{if}(a.eq.0)\textcolor{VioletRed}{errexit}('illegal value ',a)\\
s=3/a; \textcolor{green}{!\,division\,with\,zero\,is\,teste\,automatically}\\
/\\
a=3.7\\
\textcolor{VioletRed}{call}(tr)\\
tr(s); \textcolor{green}{!tr\,can\,also\,be\,used\,as\,a\,function}\\
a=0\\
\textcolor{VioletRed}{call}(tr)
\end{example}
\subsection{\textcolor{VioletRed}{goto}()}\index{goto()}
\label{goto}
Control can be transfered to a line in a transformation set with \textcolor{VioletRed}{goto}().
\begin{example}[gotoex]\\
\label{gotoex}
tr=\textcolor{VioletRed}{trans}()\\
i=0\\
\textcolor{VioletRed}{if}(i.eq.0)\textcolor{VioletRed}{goto}(koe)\\
'here';\\
koe:ch='here2';\\
/\\
\textcolor{VioletRed}{call}(tr)\\
ch;\\
Continue=1\\
tr=\textcolor{VioletRed}{trans}()\\
i=0\\
\textcolor{VioletRed}{if}(i.eq.0)\textcolor{VioletRed}{goto}(koe)\\
'here';\\
\textcolor{VioletRed}{do}(i,1,3)\\
koe:i;\\
enddo\\
/
\end{example}
\begin{note}
It is not allowed to jump in to a loop or into if -then structure. This is
checked already in in the interpreter.
\end{note}
\begin{note}
It is not yet possible to continue within an include file using Continue=1.
\end{note}
\begin{note}
It is not recommended to use \textcolor{VioletRed}{goto}() according to modern computation practices.
However, it was easier to implement cycle and exitdo with \textcolor{VioletRed}{goto}(), especially if
cycle or exitdo does not apply hte innermost do-loop.
\end{note}
\subsection{Derivatives with \textcolor{VioletRed}{der}()}\index{der()}
\label{der}
Derivates of a function with respect to any of its arguments can be
computed using the derivation rules by using \textcolor{VioletRed}{der}() function in the previous line. The funcion must be expressed with
one-line statement. The function can call other functions using the standard way
to obtain objects from transformations, but these functions cannot
contain variables for which derivatives are obtained.
Nonlinear regression needs the derivatives with respect to the parameters.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output  \tabto{3cm}    \tabto{5cm}     \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The \textcolor{VioletRed}{der}() function does not have an explicit output, but
\textcolor{VioletRed}{der}() accompanied with the function produces REAL ]d[[] variable for each of the
argument variables.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args  \tabto{3cm} 1-  \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent   ]d[[Argi] variable will get the value of the derivative wiht
respect to the argument \textcolor{teal}{Argi}.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[derex]Derivatives with \textcolor{VioletRed}{der}()\\
\label{derex}
tr=\textcolor{VioletRed}{trans}()\\
\textcolor{VioletRed}{der}(x)\\
f=(1+x)*cos(x)\\
/\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}tr(d[x]),\textcolor{blue}{x->}x,\textcolor{blue}{xrange->}(0,10),\textcolor{blue}{color->}Blue)\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}tr(f),\textcolor{blue}{x->}x,\textcolor{blue}{xrange->}(0,10),\textcolor{blue}{color->}Cyan,\textcolor{blue}{append->})
\end{example}
\begin{example}[derex2]2\\
\label{derex2}
X=\textcolor{VioletRed}{matrix}(\textcolor{blue}{do->}(0,1000,10))\\
e=\textcolor{VioletRed}{matrix}(\textcolor{VioletRed}{nrows}(X))\\
e=\textcolor{VioletRed}{rann}(0,2);\\
A,Pmax,R=0.1,20,2\\
A*Pmax*1000/(A*1000+Pmax);\\
Y=A*Pmax*X/.(A*X+Pmax)-R+e \,\textcolor{green}{!rectangular\,hyperbola\,used\,often\,for\,photosynthesis}\\
rect=\textcolor{VioletRed}{trans}()\\
\textcolor{VioletRed}{der}(A,Pmax,R)\\
f=A*Pmax*I/(A*I+Pmax)-R\\
/\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}(rect(f)),\textcolor{blue}{x->}I,\textcolor{blue}{xrange->}(0,1000),\textcolor{blue}{color->}Orange,\textcolor{blue}{width->}2,\textcolor{blue}{continue->},\textcolor{blue}{show->}0)\\
da=\textcolor{VioletRed}{newdata}(X,Y,e,\textcolor{blue}{extra->}(Regf,Resid),\textcolor{blue}{read->}(I,P,er))\\
\textcolor{VioletRed}{stat}()\\
fi=\textcolor{VioletRed}{plotyx}(P,I,\textcolor{blue}{append->},\textcolor{blue}{show->}0,\textcolor{blue}{continue->})\\
A,Pmax,R=0.07,17,3 \textcolor{green}{!initial\,values}\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}(rect(f)),\textcolor{blue}{x->}I,\textcolor{blue}{xrange->}(0,1000),\textcolor{blue}{color->}Green,\textcolor{blue}{width->}2,\textcolor{blue}{append->},\textcolor{blue}{show->}0,\textcolor{blue}{continue->})\\
reg=\textcolor{VioletRed}{nonlin}(P,f,\textcolor{blue}{par->}(A,Pmax,R),\textcolor{blue}{var->},\textcolor{blue}{corr->},\textcolor{blue}{data->}da,\textcolor{blue}{trans->}rect)\\
reg\%var;\\
reg\%corr;\\
\textcolor{VioletRed}{corrmatrix}(reg\%var);\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}(rect(f)),\textcolor{blue}{x->}I,\textcolor{blue}{xrange->}(0,1000),\textcolor{blue}{color->}Violet,\textcolor{blue}{append->})
\end{example}
\subsection{Density for normal distribution: \textcolor{VioletRed}{pdf}()}\index{pdf()}
\label{pdf}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output  \tabto{3cm}  1  \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  the value of the density.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args  \tabto{3cm} 0-2  \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  \textcolor{teal}{Arg1} is the mean (default 0), \textcolor{teal}{Arg2} is the standard deviation
(default 1). If sd is given, the mean must be given explicitly as teh first argument.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
See example drawclassex for an utilization of \textcolor{VioletRed}{pdf}()
\end{note}
\subsection{Cumulative distribution function for normal and chi2: \textcolor{VioletRed}{cdf}}\index{cdf()}
\label{cdf}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1  \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The value of the cdf.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args  \tabto{3cm}  1-3  \tabto{5cm}   REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  \textcolor{teal}{Arg1} the upper limit of the integral. When \textcolor{blue}{chi2->} is not present, then
\textcolor{teal}{Arg2}, if present is the mean of the normal distribution (defaul 0), and \textcolor{teal}{Arg3}, if present,
is the sd of the ditribution. If \textcolor{blue}{chi2->} is present, then oblicatory \textcolor{teal}{Arg2} is
ifs the number of degrees of freedom for chi2-distribution.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{chi2}  \tabto{3cm}  N |0  \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent \noindent chi2  \tabto{3cm}  N |0  \tabto{5cm}    \tabto{7cm}
\end {changemargin}
\hline
\vspace{0.2cm}
\section{Random number generators}
\label{randomgen}
Random number generators are taken from Ranlib library of Netlib.
They can produce single REAL variables or random MATRIX objects.
Random matrices are produced by defining first a matrix with \textcolor{VioletRed}{matrix}()
funtion and putting that as the output.
\subsection{Generate an uniform random number}
\label{ran}
Uniform random numbers between 0 and 1 are generating usig Netlib function ranf.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}   REAL |MATRIX   \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The generated REAL value or MATRIX.
Random matrix cab generated by defining first the matrix with \textcolor{VioletRed}{matrix}().
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[ranex]\\
\label{ranex}
\textcolor{VioletRed}{ran}();\\
\textcolor{VioletRed}{ran}();\\
cpu0=cpu()\\
A=\textcolor{VioletRed}{matrix}(10000,5)\\
A=\textcolor{VioletRed}{ran}()\\
\textcolor{VioletRed}{mean}(A);\\
\textcolor{VioletRed}{mean}(A,\textcolor{blue}{any->}) \textcolor{green}{!mean\,over\,all\,elements}\\
\textcolor{VioletRed}{mean}(A(All,2));\\
\textcolor{VioletRed}{sd}(A);\\
\textcolor{VioletRed}{sd}(A,\textcolor{blue}{any->});\\
\textcolor{VioletRed}{min}(A);\\
\textcolor{VioletRed}{min}(A,\textcolor{blue}{any->});\\
\textcolor{VioletRed}{max}(A);\\
cpu()-cpu0;
\end{example}
\subsection{\textcolor{VioletRed}{rann}()}\index{rann()}
\label{rann}
Computes normally distributed pseudo random numbers into a REAL variable or
into MATRIX.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 1 \tabto{5cm}  REAL|MATRIX \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The matrix to be generated bus be defined earlier with \textcolor{VioletRed}{matrix}().cm} er
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 0-2 \tabto{5cm}  num \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  rannn() produces N(0,1) variables, \textcolor{VioletRed}{rann}(mean) will produce
N(mean,1) variables and \textcolor{VioletRed}{rann}(mean,sd) procuses N(mean,sd) variables.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[rannex]Random normal variates, illustrating also find\\
\label{rannex}
rx=\textcolor{VioletRed}{rann}() \,\textcolor{green}{!Output\,is\,REAL}\\
rm=\textcolor{VioletRed}{matrix}(100)\\
\textcolor{VioletRed}{print}(\textcolor{VioletRed}{mean}(rm),\textcolor{VioletRed}{sd}(rm),\textcolor{VioletRed}{min}(rm),\textcolor{VioletRed}{max}(rm))\\
large=\textcolor{VioletRed}{find}(rm,\textcolor{blue}{filter->}(\$.ge.2),any)\\
\textcolor{VioletRed}{print}(100*nrows(large)/\textcolor{VioletRed}{nrows}(rm))\\
cpu0=cpu()\\
rm2=\textcolor{VioletRed}{matrix}(1000000)\\
rm2=\textcolor{VioletRed}{rann}(10,2) \,\textcolor{green}{!there\,cannot\,be\,arithmetix\,opreations\,in\,the\,right\,side}\\
cpu()-cpu0;\\
\textcolor{VioletRed}{mean}(rm2),\textcolor{VioletRed}{sd}(rm2),\textcolor{VioletRed}{min}(rm2),\textcolor{VioletRed}{max}(rm2);\\
large=\textcolor{VioletRed}{find}(rm,\textcolor{blue}{filter->}(\$.ge.14),\textcolor{blue}{any->})\\
\textcolor{VioletRed}{print}(100*nrows(large)/\textcolor{VioletRed}{nrows}(rm))\\
!
\end{example}
\begin{note}
When generating a matrix with random numbers, there cannot be
arithmetic operations on the right side.That means that code:\newline
rm=\textcolor{VioletRed}{matrix}(100)\newline
rm=2*rann()\newline
would produce a REAL value rm.
\end{note}
\subsection{Generate random binomial values}
\label{ranbin}
Binomial random numbers between 0 and n are generating usig Netlib
ignbin(n,p).Random matrix can generated by defining first
the matrix with \textcolor{VioletRed}{matrix}().
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}   REAL |MATRIX   \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The generated REAL value or MATRIX with
number of successes. (J does not have explicit integer type object).
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args  \tabto{3cm} 2 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  \textcolor{teal}{Arg1} is the number of trials (n) and \textcolor{teal}{Arg2} is the probability
of succes in one trial.
!
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[ranbinex]x\\
\label{ranbinex}
\textcolor{VioletRed}{ranbin}(10,0.1);\\
\textcolor{VioletRed}{ranbin}(10,0.1);\\
!\\
A=\textcolor{VioletRed}{matrix}(1000,2)\\
A(All,1)=\textcolor{VioletRed}{ranbin}(20,0.2)\\
A(All,2)=\textcolor{VioletRed}{ranbin}(20,0.2)\\
da=\textcolor{VioletRed}{newdata}(A,\textcolor{blue}{read->}(s1,s2))\\
\textcolor{VioletRed}{stat}()\\
cl=\textcolor{VioletRed}{classify}(1,\textcolor{blue}{x->}s1)\\
fi=\textcolor{VioletRed}{drawclass}(cl,\textcolor{blue}{histogram->},\textcolor{blue}{color->}Blue)\\
cl=\textcolor{VioletRed}{classify}(1,\textcolor{blue}{x->}s2)\\
fi=\textcolor{VioletRed}{drawclass}(cl,\textcolor{blue}{histogram->},\textcolor{blue}{color->}Red,\textcolor{blue}{append->})
\end{example}
\subsection{Generate negative binomial variates: \textcolor{VioletRed}{rannegbin}()}\index{rannegbin()}
\label{rannegbin}
The  function  returns  random  number  distributed  according to the
negative binomila distribution.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 1 \tabto{5cm}  REAL | MATRIX  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  the number of successes in
independent Bernoul trials before r’th failure when
p is the probability of success. \textcolor{VioletRed}{ranbin}(r,1)returns 1.7e37 and
\textcolor{VioletRed}{ranbin}(r,0)returns 0.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{green}{!Args\,\tabto{3cm}\,\,\tabto{5cm}\,\,REAL\,\tabto{7cm}\,}
\begin{changemargin}{3cm}{0cm}
\noindent  r=\textcolor{teal}{Arg1} and p=\textcolor{teal}{Arg1}
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
there are different ways to define the negative binomial distribution. In this definition
a Poisson random variable with mean \$\lamda\$ is obtained by letting r go
to infinity and defining p= \$\lamda\$/( \$\lamda\$+r)
The mean E(x) of this definition is p*r/(1-p) and the variance is V=p*r/(1-p)2. Thus given
E(x) and V, r and p can be obtained as follows: p=1- E(x) /V and r= E(x)**2/(V- E(x)) . This is useful when
simulating ‘overdispersed Poisson’ variables. Sorry for the (temporary) inconsistency of parameters with
function \textcolor{VioletRed}{negbin}().
\end{note}
\begin{note}
can also have a noninteger values. This is not in accordance with the above
interpretation of the distribution, but it is compatible with interpreting negative binomial
distribution as a compound gamma-Poisson distribution and it is useful when simulating
overdispersed Poisson distributions.
\end{note}
\subsection{Random selection of elemets}
\label{select}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 1 \tabto{5cm}  MATRIX  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent column vector with n elements indicating random
selection of k
elements out of n elements. The selection is with without replacement,
thus elements of the output are 1 or 0..
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 2 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  k=\textcolor{teal}{Arg1} and n=\textcolor{teal}{Arg2}.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[selectex]Random selection\\
\label{selectex}
S=\textcolor{VioletRed}{select}(500,10000)\\
\textcolor{VioletRed}{mean}(S),\textcolor{VioletRed}{sum}(S),500/10000;
\end{example}
\subsection{Object lists}
\label{listo}
An object list is a list of named \textbf{J} object. See Shortcuts for implicit object
lists and List functions for more details. Object lists can be used also as
pointers to objects, see e.g. the selector option of the simulate() function.
\subsection{\textcolor{VioletRed}{list}() generates a LIST object}\index{list()}
\label{list}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}   LIST  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The generated LIST object.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm}  0-  \tabto{5cm}     \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  named objects. If an argument is LIST it is ex+panded
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{mask} \tabto{3cm}  N|1-  \tabto{5cm}  REAl \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Which object are picked from the list of arguments.\ta
value 0 indicates that
he object is dropped, positive value indicates how many variables are taken,
negative value how many objects are dropped (thus 0 is equivalent to -1). mask-
option is useful for creating sublists of long lists.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
The same object may appear several times in the list. (see \textcolor{VioletRed}{merge}())ge
\end{note}
\begin{note}
There may be zero arguments, which result in an empty list
which can be updated later.
\end{note}
\begin{note}
The index of object in a LIST can be obtained using \textcolor{VioletRed}{index}().ex
\end{note}
\\
li=\textcolor{VioletRed}{list}(x1...x3);
\\
\textcolor{VioletRed}{index}(x2,li);
\\
Continue=1
\\
\textcolor{VioletRed}{index}(x4,li); \,\textcolor{green}{!\,error}
\\
Continue=0
\\
\begin{example}[list2ex]x\\
\label{list2ex}
all=\textcolor{VioletRed}{list}(); \,\textcolor{green}{!\,empty\,list}\\
sub=\textcolor{VioletRed}{list}();\\
nper=3\\
\textcolor{Red}{;do}(i,1,nper)\\
period\#"i"=\textcolor{VioletRed}{list}(ba\#"i",vol\#"i",age\#"i",harv\#"i")\\
sub\#"i"=\textcolor{VioletRed}{list}(@period\#"i",\textcolor{blue}{mask->}(-2,1,-1))\\
all=\textcolor{VioletRed}{list}(@all,@period\#"i") \textcolor{green}{!note\,that\,all\,is\,on\,both\,sides}\\
sub=\textcolor{VioletRed}{list}(@sub,@sub\#"i")\\
;end do
\end{example}
\subsection{\textcolor{VioletRed}{merge}()}\index{merge()}
\label{merge}
\textcolor{VioletRed}{merge}() will produce of list consisting of separate objects
in argument lists and argument objects.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 1 \tabto{5cm}  LIST \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent A list which is produced by first putting all elements of
argument lists and non-list arguments into a vector, and then duplicate objects are dropped.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 2- \tabto{5cm}  LIST|OBJ \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  LIST and separate non-list objects.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[mergex]Merging list\\
\label{mergex}
x1...x3=1,2,3\\
mat=\textcolor{VioletRed}{matrix}(3,\textcolor{blue}{values->}(4,5,6))\\
lis0=\textcolor{VioletRed}{list}(x2,x1)\\
lis2=\textcolor{VioletRed}{merge}(x1,mat,lis0)\\
\textcolor{VioletRed}{print}(lis2)
\color{Green}
\begin{verbatim}
<print(lis2)
lis2 is list with            3  elements:
x1 mat x2
\end{verbatim}
\color{Black}
\end{example}
\subsection{List of integers}
\label{ilist}
Generates a list of integers which can be used as indexes. This function
is used implicitly with {}.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}   ILIST  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The generated ILIST.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm}  0-  \tabto{5cm}  REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Values to be put into ILIST, or the dimesion
of the ILIST when values are given in \textcolor{blue}{values->},  or variables whose indeces
in in the data are put into the ILIST.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{data} \tabto{3cm} N|1 \tabto{5cm}   DATA \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The DATA object from whose variable indeces are obtained.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{extra}  \tabto{3cm}  1 \tabto{5cm}  REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Extra space reserved for later updates of the ILIST.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{values}  \tabto{3cm} N|1- \tabto{5cm}   REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Values to be put into ILIST when dimesnion is determined as the
only argument
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
ILIST is a new object whose all utilization possiblities are not yet explored.
It will be used e.g. when developing factory optimization.
\end{note}
\begin{note}
eote
Using \textcolor{VioletRed}{ilist}() by giving the dimension as argument and values with \textcolor{blue}{values->} option
imitates the definition of a matrix (column vector). The structure of ILIST object
is the same as LIST object which can be used in matrix computations.
\end{note}
\begin{example}[ilistex]ILIST examples\\
\label{ilistex}
{1,4,5};\\
{4...1};\\
A=\textcolor{VioletRed}{matrix}(4,4)\\
A({1,5},{3}=
\end{example}
\subsection{_o exist\_o(): does an object exist}
\label{exist}
looks whether an object with the name given in
the character constant  argument exists.
\begin{note}
In the prvious versions of \textbf{J} same function was used for files and objects.
\end{note}
\subsection{Deleting objects: delete\_o()}
\label{delete}
When an object with a given name is created, the name cannot be removed. With
delete\_0() function one can free all memory allocated for data structures needed
by general objects:
delete\_o(obj1,…,objn)
After deleting an object, the name refers to a real variable (which is
initialized by the delete\_o() function into zero).
\begin{note}
Other objects except matrices can equivalently be deleted by giving
command
obj1,…,objn = 0
This is because the output objects of any functions are first deleted before
defining them anew. Usually an object is automatically deleted if the object
name is as an output object for other functions.
\end{note}
\begin{note}
One can see how much memory each object is using \textcolor{VioletRed}{print}(Names).mes
\end{note}
\begin{note}
Deleting a compound object deletes also such
subobjects which have no meaning when the main object is deleted. But e.g. if a
data object is deleted then the as-sociated transformation object is not
deleted as the transformation can be used independently.
\end{note}
\begin{note}
Files can be deleted with delete\_f(file). See IO-functions for
details.
\end{note}
\begin{note}
If the user has defined own new compound objects in the open source
\textbf{J} software she/he needs to define the associated delete function.
\end{note}
\subsection{Create a matrix: \textcolor{VioletRed}{matrix}()}\index{matrix()}
\label{matrix}
Function \textcolor{VioletRed}{matrix}() creates a matrix and puts REAL values to the elements. Element values
can be read from the input paragraph, file, or the values can be generated
using \textcolor{blue}{values->} option, or sequential values can be generated
using \textcolor{blue}{do->} option. Function \textcolor{VioletRed}{matrix}() can generate a diagonal and block diagonal matrix.
A matrix can be generated from submatrices by using matrices as arguments
of the  \textcolor{blue}{values->} option. It should be noted that matrices are stored in row order.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}   MATRIX | REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  If a 1x1 matrix is defined, the output will be REAL.
The output can be a temporary matrix without name, if \textcolor{VioletRed}{matrix}() is an argument
of an arithmetic function  or matrix function. If no element values are
given in \textcolor{blue}{values->} or obtained from \textcolor{blue}{in->} input, all elemets get value zero.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 0-2 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The dimension of the matrix. The first argument gives the number of rows,
the second argument, if present, the number of columns.  If the matrix is generated from submatrices given in \textcolor{blue}{values->}, then the dimensions
refer to the submatrix rows and submatrix columns. If there are no arguments, then the
it should be possible to infer the dimensions from \textcolor{blue}{values->} option. If the
first argument is \textcolor{teal}{Inf}, the the number of rows is determined by the number
number of lines in source determined by \textcolor{blue}{in->}.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{in} \tabto{3cm} N|0|1 \tabto{5cm}  CHAR \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The input for values. \textcolor{blue}{in->} means that values are read in from
the following input paragraps, \textcolor{blue}{in->}\textcolor{teal}{file} means that the values are read from file.
in both cases a record must contain one row for the matrix.
If there is reading error and values are read from the terminal, \textbf{J} gives
possibility to continue with better luck, otherwise an error occurs.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{values} \tabto{3cm} N|1- \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent values or MATRIX objects put to the matrix. The argumenst of
\textcolor{blue}{values->} option go in the regular way
through the interpreter, so the values can be obtained by computations. If only one REAL value is
given then all diagonal elements are put equal to the value (ohers will be zero),
if \textcolor{blue}{diag->} option is present, otherwise all elements are put equal to this value. If matrix dimensions
are given, and there are fewer values than is the size the matrix, matrix is
filled row by row using all values given in
\textcolor{blue}{values->}. If there are more values as is the size, an error occurs unless there is
\textcolor{blue}{any->} option present.
Thus \textcolor{VioletRed}{matrix}(N,N,\textcolor{blue}{values->}1) generates the identity matrix.
If value-> refers to one MATRIX,and \textcolor{blue}{diag->} is present then a block diagonal
matrix is generated. Without \textcolor{blue}{diag->}, a partitioned matrix is generated having all
submatrices equal
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{do}  \tabto{3cm} N|0-3 \tabto{5cm}  REAL   \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  A matrix of number sequences is generated, as followsws: \newline
\textcolor{blue}{do->} Values 1,2,...,\textcolor{teal}{arg1} x \textcolor{teal}{arg2} are put into the matrix in the row order. \newline
\textcolor{blue}{do->}5 Values 5,6,...,\textcolor{teal}{arg1} x \textcolor{teal}{arg2}+4 are put into the matrix \newline
\textcolor{blue}{do->}
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[matrixex]Example of generating matrices\\
\label{matrixex}
A=\textcolor{VioletRed}{matrix}(3,
\end{example}
\subsection{\textcolor{VioletRed}{inverse}()}\index{inverse()}
\label{inverse}
\textcolor{VioletRed}{inverse}(A) computes the inverse of a square MATRIX A. The function utilized dgesv funtion
of netlib. If the argument has type REAL, then the reciprocal is computed,
and the output will also have type REAL. An error occurs, if A is not
a square matrix or REAL, or A is singular according to dgesv.
\begin{note}
instead of writing c=\textcolor{VioletRed}{inverse}(a)*b, it is faster and more accurate to
write c=\textcolor{VioletRed}{solve}(a,b)
\end{note}
\subsection{\textcolor{VioletRed}{qr}()}\index{qr()}
\label{qr}
Makes QR decomposition of a MATRIX This can be used to study if columns of a are linearly
dependent. \textbf{J} prints a matrix which indicates the structure of the upper diagonal matrix R in the
qr decomposition. If column k is linearly dependent on previous columns the k’th diagonal
element is zero. If output is given, then it will be the r matrix. Due to rounding errors diagonal
elements which are interpreted to be zero are not exactly zero. Explicit r matrix is useful if user
thinks that \textbf{J} has not properly interpreted which diagonal elements are zero.
In \textbf{J}  \textcolor{VioletRed}{qr}() may be useful when it is studied why a matrix which shoudl
be nonsingular turns out to be singular in \textcolor{VioletRed}{inverse}() or \textcolor{VioletRed}{solve}().
\textcolor{VioletRed}{qr}() is using  the subroutine dgeqrf from Netlib.
An error occurs if the argument is not MATRIX or if dgeqrf produces
error code, which is just printed.
Now the function just shows the linear dependencies, as sho in the examples.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 1 \tabto{5cm}  MATRIX \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent A m-by-n MATRIX.
\end {changemargin}
\hline
\vspace{0.2cm}
\subsection{\textcolor{VioletRed}{eigen}()}\index{eigen()}
\label{eigen}
Computes eigenvectors and eigenvalues of a square matrix. The eigenvectors are stored as
columns in matrix output\%matrix and the eigenvalues are stored as a row vector
output\%values. The eigenvalues and eigenvectors are sorted from smallest to larges eigenvalue.
Netlib subroutines DLASCL, DORGTR, DSCAL, DSTEQR, DSTERF, DSYTRD,
XERBLA, DLANSY and DLASCL are used.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 1 \tabto{5cm}  MAT \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  A square MATRIX.
\end {changemargin}
\hline
\vspace{0.2cm}
\subsection{\textcolor{VioletRed}{find}()}\index{find()}
\label{find}
Function \textcolor{VioletRed}{find}() can be used to find the first matrix element satisfying a given condition, or
all matrix elements satifying the conditon, and in that case the found
elements can be put to a vector containg element numbers or to a
vector which has equal size as the input matrix and where 1 indicates that
the element satifies the condition..
Remember that matrices are stored in row order. If a given column or row should be seaeched,
use submatrix() to extract that row or column.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}   REAL|MATRIX \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Without \textcolor{blue}{any->} or \textcolor{blue}{expand->} the first element found in row order.
With \textcolor{blue}{any->}, the vector of element numbers satisfying the conditon. If nothing found
the output will be REAL with value zero.
With \textcolor{blue}{expand->}, the matrix of the same dimensions as the input matrix where
hits are marked with 1.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 1 \tabto{5cm}  Matrix \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The matrix searched.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{filter} \tabto{3cm} 1 \tabto{5cm}  Code \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Gives the condition which the matrix element should be satisfied. The
values of the matrix elements are put to the variable \$.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{any} \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The filtered element numbers are put to the output vector.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{expand} \tabto{3cm} -1|0 \tabto{5cm}   \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The filtered elements are put the output matrix
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[findex]Example of find, illustrating also \textcolor{VioletRed}{rann}()\\
\label{findex}
\textcolor{green}{!Repeating\,the\,example,\,different\,results\,will\,be\,obtained}\\
rm=\textcolor{VioletRed}{matrix}(100)\\
m,s=2,3\\
rm=\textcolor{VioletRed}{rann}(m,s)\\
\textcolor{VioletRed}{print}(\textcolor{VioletRed}{mean}(rm),\textcolor{VioletRed}{sd}(rm),\textcolor{VioletRed}{min}(rm),\textcolor{VioletRed}{max}(rm))
\color{Green}
\begin{verbatim}
=   2.4564691829681395
=   3.2549002852383477
=  -5.6481685638427734
=   10.714715003967285
\end{verbatim}
\color{Black}
first=\textcolor{VioletRed}{find}(rm,\textcolor{blue}{filter->}(\$.ge.m+1.96*s))\\
large=\textcolor{VioletRed}{find}(rm,\textcolor{blue}{filter->}(\$.ge.m+1.96*s),\textcolor{blue}{any->})\\
large2=\textcolor{VioletRed}{find}(rm,\textcolor{blue}{filter->}(\$.ge.m+1.96*s),\textcolor{blue}{expand->})\\
\textcolor{VioletRed}{print}(first,100*nrows(large)/\textcolor{VioletRed}{nrows}(rm),100*sum(large2)/\textcolor{VioletRed}{nrows}(rm))
\color{Green}
\begin{verbatim}
first=   12.000000000000000
=   4.0000000000000000
=   4.0000000000000000
\end{verbatim}
\color{Black}
\end{example}
\subsection{Making correaltion matrix from variance-covariance amtrix: \textcolor{VioletRed}}\index{corrmatrix()}
\label{corrmatrix}
This simple function is sometimes needed. The function does not test wether the input matrix is symmetric.
Negative diagonal eleemnt produces error, value zero correaltion 9,99.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}   MATRIX \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  matrix having nondiagonal values \textcolor{teal}{Out}(i,j)=\textcolor{teal}{arg}(i,j)=
\textcolor{teal}{arg}(i,j)/\textcolor{VioletRed}{sqrt}(\textcolor{teal}{arg}(i,i)*]arg[(j,j)).
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args  \tabto{3cm} 1 \tabto{5cm}   MATRIX \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  symmetric matrix
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{sd} \tabto{3cm} N|0  \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent If \textcolor{blue}{sd->} is given, then diagonal elements will be equal to \textcolor{VioletRed}{sqrt}(\textcolor{teal}{arg}(i,i)
\end {changemargin}
\hline
\vspace{0.2cm}
\subsection{\textcolor{VioletRed}{data}()}\index{data()}
\label{data}
Data objects are created with the \textcolor{VioletRed}{data}() function. Two linked data objects can be created with the
same function call (using option \textcolor{blue}{subdata->} and options thereafter in the following
description). It is recommended that two linked data objects are created with one \textcolor{VioletRed}{data}()
function call only in case the data is read from a single file where subdata observations are
stored immediately after the upper data observation.  Data objects can be linked also afterwards with the \textcolor{VioletRed}{linkdata}() function.
A data object can created by a \textcolor{VioletRed}{data}() function when data are read from files
or data are created using transformation objects. New data objects can
be created with \textcolor{VioletRed}{newdata}() function from previous data objects and/or matrices.
If data objects can created using transformation objects either with \textcolor{VioletRed}{data}() function
or by creating first data matrix by transformation and then using \textcolor{VioletRed}{newdata}() to
create data object.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output  \tabto{3cm} 0|1 \tabto{5cm}  Data \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent \noindent Output  \tabto{3cm} 0|1 \tabto{5cm}  Data \tabto{7cm}
Data object to be created. If there is no output then the default is \$Data\$.
It is recommended that this default is used only when only one data object
is used in the analysis.
!
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{read}  \tabto{3cm} 0|1- \tabto{5cm}  REAL|List \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Variables read from the input files or the name of the list containing all variables
to be read in. If no arguments are given and there is no readfirst-> option
then the variables to read in are stored in the first line of the data file separated
with commas.?? Also the … -shortcut can be used to define the varaible list. If no arguments are given and
there is readfirst-> option then the variable names are read from the second
line.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{in}  \tabto{3cm} 0- \tabto{5cm}  Char \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent input file or list of input files. If no files are given, data is read from the following input
paragraph. If either of \textcolor{blue}{read->} or \textcolor{blue}{in->} option is given, then both options must
be present.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{form}  \tabto{3cm} -1|1 \tabto{5cm}  Char \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Format of the data as follows \newline
\$  Fortran format '*', the default \newline
b    Single precison binary \newline
bs  Single precison binary opened with access='stream'
Needed for Pascal files in Windows. \newline
B  Double precison binary.\newline
Char giving a Fortran format, e.g. '(4f4.1,1x,f4.3)' \newline
d4 Single precison direct access for Gfortran files.\newline
d1 Single precison direct acces for Intel Fortran files.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{maketrans} \tabto{3cm} -1|1 \tabto{5cm}  TRANS  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Transformations computed for each observation when reading the data
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{keep} \tabto{3cm} -1|1- \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  variables kept in the data object, default: all \textcolor{blue}{read->} variables plus the output
variables of \textcolor{blue}{maketrans->} transformations.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{obs} \tabto{3cm} -1|1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Variable which gets automatically the observation number when working with the
data, variable is not stored in the data matrix, default: Obs. When working with
hierarchical data it is reasonable to give obs variable for each data object.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{filter} \tabto{3cm} -1|1 \tabto{5cm}  Code \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  logical or arithmetic statement (nonzero value indicating True) describing which
observations will be accepted to the data object. \textcolor{blue}{maketrans->}-transformations are
computed before using filter. Option \textcolor{blue}{filter->} can utilize automatically created
variable Record which tells which input record has been just read. If observations
are rejected, then the Obs-variable has as its value number of already accepted
observations+1.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{reject}  \tabto{3cm} -1|1 \tabto{5cm}  Code \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Logical or arithmetic statement (nonzero value indicating True) describing which
observations will be rejected from the data object. If \textcolor{blue}{filter->} option is given then
reject statement is checked for observations which have passed the filter. Option
\textcolor{blue}{reject->} can utilize automatically created variable Record which tells which
input record has been just read. If observations are rejected, then the Obsvariable has as its value number of already accepted observations+1.
subdata the name of the lower level data object to be created. This option is not allowed, if
there are multiple input files defined in option \textcolor{blue}{in->}.
subread,…,subobs sub data options similar as \textcolor{blue}{read->}…obs-> for the upper level data.
(\textcolor{blue}{subform->}'bgaya' is the format for the Gaya system). The following options
can be used only if \textcolor{blue}{subdata->} is present
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{nobsw}  \tabto{3cm}  -1|1  \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  A variable in the upper data telling how many subdata observations there is under
each upper level observation, necessary if \textcolor{blue}{subdata->} option is present.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{nobswcum} \tabto{3cm} -1|1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  A variable telling the cumulative number of subdata observations up to the
current upper data observation but not including it. This is useful when accessing
the data matrix one upper level unit by time, i.e., the observation numbers within
upper level observation are nobswcum+1,…,nobswcum+nobsw
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{obsw} \tabto{3cm} -1|1 \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  A variable in the subdata which automatically will get the number of observation
within the current upper level observation, i.e. obsw variable gets values from 1
to the value of nobsw-variable, default is 'obs\_variable\%obsw'.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{duplicate} \tabto{3cm} -1|2 \tabto{5cm}   TRANS  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent \noindent duplicate \tabto{3cm} -1|2 \tabto{5cm}   TRANS  \tabto{7cm}
The two transformation object arguments describe how observations in the subdata
will be duplicated. The first transformation object should have Duplicates as an
output variable so that the value of Duplicates tells how many duplicates ar
made (0= no duplication). The second transformation object defines how the values
of subdata variables are determined for each duplicate. The number of duplicate
is transmitted to the variable Duplicate. These transformations are called also
when Duplicate=0. This means that when there is the \textcolor{blue}{duplicate->} option,
then all transformations for the subdata can be defined in the duplicate
transformation object, and \textcolor{blue}{submaketrans->} is not necessary.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{oldsubobs} \tabto{3cm} -1|1 \tabto{5cm}   REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  If there are duplications of sub-observations, then this option gives the variable
into which the original observation number is put. This can be stored in the
subdata by putting it into \textcolor{blue}{subkeep->} list, or, if \textcolor{blue}{subkeep->} option is not given
then this variable is automatically put into the \textcolor{blue}{keep->} list of the subdata.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{oldobsw} \tabto{3cm} -1|1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  This works similarly with respect to the initial obsw variable as \textcolor{blue}{oldsubobs->}
works for initial obs variable.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{nobs} \tabto{3cm} -1|1 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  There are two uses of this option. First, a data object can be created without reading
from a file or from the following input paragraph by using \textcolor{blue}{nobs->} option and
\textcolor{blue}{maketrans->} transformation, which can use Obs variable as argument. Creation
of data object this way is indicated by the presence of \textcolor{blue}{nobs->} option and absence
of \textcolor{blue}{in->} and \textcolor{blue}{read->} options. Second, if \textcolor{blue}{read->} option is present \textcolor{blue}{nobs->}
option can be used to indicate how many records are read from a file and what
will be the number of observations. Currently \textcolor{blue}{reject->} or \textcolor{blue}{filter->} can not
be used to reject records (consult authors if this would be needed). If there are
fewer records in file as given in \textcolor{blue}{nobs->} option, an error occurs. There are three
reasons for using \textcolor{blue}{nobs->} option this way. First, one can read a small sample
from a large file for testing purposes. Second, the reading is slightly faster as the
data can be read directly into proper memory area without using linked buffers.
Third, if the data file is so large that a virtual memory overflow occurs, then it may
be possible to read data in as linked buffers are not needed.
In case \textcolor{blue}{nobs->} option is present and \textcolor{blue}{read->} option is absent either
\textcolor{blue}{maketrans->} or \textcolor{blue}{keep->} option (or both) is required.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{buffersize} \tabto{3cm} -1|1 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent \noindent buffersize \tabto{3cm} -1|1 \tabto{5cm}  Real \tabto{7cm}
The number of observations put into one temporary working buffer. The default
is 10000. Experimentation with different values of \textcolor{blue}{buffersize->} in huge data
objects may result in more efficient \textcolor{blue}{buffersize->} than is the default (or perhaps
not). Note that the buffers are not needed if number of observations is given in
\textcolor{blue}{nobs->}.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{par} \tabto{3cm} -1|1- \tabto{5cm}   Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent additional parameters for reading. If \textcolor{blue}{subform->} option is 'bgaya' then par
option can be given in form \textcolor{blue}{par->}(ngvar,npvar) where ngvar is the number
of nonperiodic x-variables and npvar is the number of period specific x-variables
for each period. Default values are \textcolor{blue}{par->}(8,93).
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{rfhead}  \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  When reading data from a text file, the first line can contain a header which is
printed but othewise ignored
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{rfcode}  \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The data file can contain also J-code which is first executed. Note the code can
be like var1,var,x1...x5=1,2,3,4,5,6,7, which give the possibility to
define variables which describe the \textcolor{blue}{in->} file.
rfsubhead-> works for subdata similarly as \textcolor{blue}{rfhead->} for data.
rfsubcode works for subdata similarly as \textcolor{blue}{rfcode->} for data
If there are both \textcolor{blue}{rfhead->} and \textcolor{blue}{rfcode->} then \textcolor{blue}{rfhead->} is excuted first.
\textcolor{blue}{rfhead->} and \textcolor{blue}{rfcode->} replace readfirst-> option  of previous versions which was too
complicated.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
\textcolor{VioletRed}{data}() function will create a data object object, which is a compound object consisting
of links to data matrix, etc. see Data object object. If Data is the output
of the function, the function creates the list Data\%keep telling the
variables in the data and
Data\%matrix containg the data as a single precision matrix. The number of observations can be obtained by \textcolor{VioletRed}{nobs}(Data) or by
\textcolor{VioletRed}{nrows}(Data\%matrix).
\end{note}
\begin{note}
See common options section for how data objects used in other \textbf{J} functions will be defined.
\end{note}
\begin{note}
The \textcolor{blue}{in->} and \textcolor{blue}{subin->} can refer to the same file, or if both are without arguments
then data are in the following input paragraph. In this case \textcolor{VioletRed}{data}() function read first one
upper level record and then \textcolor{blue}{nobsw->} lower level records.
\end{note}
\begin{note}
When reading the data the \textcolor{blue}{obs->}variable (default Obs) can be used in maketrans-
> transformation and in \textcolor{blue}{reject->} option and \textcolor{blue}{filter->} option, and the variable refers to
the number of observation in resulting data object. The variable Record gets the number of
the read record in the input file, and can be used in \textcolor{blue}{maketrans->} transformations and in
\textcolor{blue}{reject->} and \textcolor{blue}{filter->} options. If \textcolor{blue}{subdata->} option is given, variable Subreject gets
the number of record in the sub file, and it can be used in \textcolor{blue}{submaketrans->} transformations
and in \textcolor{blue}{subreject->} option and in \textcolor{blue}{subfilter->} option.
\end{note}
\begin{note}
Options \textcolor{blue}{nobs->}100, \textcolor{blue}{reject->}(Record.gt.100) and \textcolor{blue}{filter->}
(Record.le.100) result in the same data object, but when reading a large file, the \textcolor{blue}{nobs->}
option is faster as the whole input file is not read.
\end{note}
\begin{note}
If no observations are rejected, obs variable and Record variable get the same values.
\end{note}
\begin{note}
If virtual memory overflow occurs, see \textcolor{blue}{nobs->} optio. This should not happen easily with the currrent
64-bit application.
\end{note}
\begin{note}
Earlier versions contained \textcolor{blue}{trans->} and \textcolor{blue}{subtrans->}options which associated
a permanent transformation object with the data object. This feature is now deleted because
it may confuse and is not really needed. If tranformations are needed in functions
they can always be included using \textcolor{blue}{trans->} .
\end{note}
\begin{example}[dataex]data() generates a new data object by reading data.\\
\label{dataex}
data1=\textcolor{VioletRed}{data}(\textcolor{blue}{read->}(x1...x3),\textcolor{blue}{in->})\\
1,2,3\\
4,5,6\\
7,8,9\\
/
\end{example}
\subsection{\textcolor{VioletRed}{newdata}()}\index{newdata()}
\label{newdata}
Function \textcolor{VioletRed}{newdata}() generates a new data object from existing data objects and/or
matrices possibly using transformations to generate new variables.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 1 \tabto{5cm}  Data \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The data object generated.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 1- \tabto{5cm}  Data|Matrix \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Input matrices and data objects.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{read} \tabto{3cm} N|1- \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Variable names for columns of matrices in the order of
matrices.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{maketrans} \tabto{3cm} N|1 \tabto{5cm}   TRANS  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  A predefined ransformation object computed for each observation.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
It is not yet possible to drop variables.
\end{note}
\begin{note}
An error occurs if the same variable is several times in the variable list obtained
by combining variables in data sets and \textcolor{blue}{read->} variables.
\end{note}
\begin{note}
An error occurs if the numbers of rows of matrices and observations in data sets
are not compatible.
\end{note}
\begin{note}
Output variables in \textcolor{blue}{maketrans->} transformations whose name start with \$ are not put into the new data object.
\end{note}
\begin{example}[newdataex]newdata() generates a new data object.\\
\label{newdataex}
data1=\textcolor{VioletRed}{data}(\textcolor{blue}{read->}(x1...x3),\textcolor{blue}{in->})\\
1,2,3\\
4,5,6\\
7,8,9\\
/\\
matrix1=\textcolor{VioletRed}{matrix}(3,2,\textcolor{blue}{in->})\\
10,20\\
30,40\\
50,60\\
/\\
newtr=\textcolor{VioletRed}{trans}()\\
\textcolor{Red}{;do}(i,1,3)\\
\textcolor{Red}{;do}(j,1,2)\\
x"i"\#z"j"=x"i"*z"j"\\
\textcolor{Red}{;enddo}\\
\textcolor{Red}{;enddo}\\
/\\
new=\textcolor{VioletRed}{newdata}(data1,matrix1,\textcolor{blue}{read->}(z1,z2),\textcolor{blue}{maketrans->}newtr)\\
\textcolor{VioletRed}{print}(new)
\end{example}
\subsection{\textcolor{VioletRed}{exceldata}()}\index{exceldata()}
\label{exceldata}
Generates data object from csv data generated with excel. It is assumed that ';' is used as column separator,
and first is the header line generated with excel and containing column names.
The second line contains information for \textbf{J} how to read the data.
First the first line is copied and pasted as the second line. To the beginning of the second line is put
'@\#'. Then each entry separated by ';' is edited as follows. If the column is just ignored, then
put '!' to the beginning of the entry. If all characters in the column are read in as
a numeric variable, change the name to accpetable variable name in J.
If the column is read in but it is just used as an input variable fot
\textcolor{blue}{maketrans->} trasformations, then start the name with '\$' so the variable is not put to
the list of \textcolor{blue}{keep->} variables. If a contains only character values then it must
be ignored using '!'. If the contains numeric values surrounded by characters, the the numeric value can be picked
as follows. Put '?' to the end of entry. Put the variable name to the beginning of the entry.
then put the the number of characters to be ignored by two digits, inserting
aleading zero if needed. The given the length of the numeric field to be read in as a numeric value.
For instance, if the header line in the excel file is
\color{Green}
\begin{verbatim}
Block;Contract;Starting time;Name of municipality;Number of stem;Species code
\end{verbatim}
\color{Black}
and the first data line could be
\color{Green}
\begin{verbatim}
MG_H100097362501;20111001;7.5.2021 9:37;Akaa;20;103;1;FI2_Spruce
\end{verbatim}
\color{Black}
then the second line before the first data line could be
\color{Green}
\begin{verbatim}
##block0808?;!Contract;!Starting time;!Name of municipality;stem;species0201?
\end{verbatim}
\color{Black}
therafter the first observation would get values block=97362501,stem=1, and
species=2.
If there are several input files, the header line of later input lines is ignored, and
also if the second line of later files starts with '\#\#', then it is ignored.
if any later lines in any input files start with 'jcode:', then the code is computed.
This way variables decribing the whole input file can be transmitted to the data.
Currently jcode-output variables can be transmitted to data matrix only by using the as pseudo
outputvariables in maketrans-transformations, e.g., filevar1=filevar1, if
filevar1 is generated in jcode transformation.
If there are several input files the file number is put into variable In before computing maketrans transformations
and this variable is automatically stored in the data matrix.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 1 \tabto{5cm}  Data \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Data object generated
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{in} \tabto{3cm} 1- \tabto{5cm}  Char \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Files to read in.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{maketrans} \tabto{3cm} N|1 \tabto{5cm}  trans \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Transformations used to compute new variables to be stored
in the data.
\end {changemargin}
\hline
\vspace{0.2cm}
\subsection{\textcolor{VioletRed}{classvector}()}\index{classvector()}
\label{classvector}
Function classvector computes vectors from data which extract information from grouped
data. These vectors can be used to generate new data object using \textcolor{VioletRed}{newdata}() function or
new matrices from submatrices using \textcolor{VioletRed}{matrix}() function with \textcolor{blue}{matrix->} option or
they can be used in transformation objects to compute class related things.
There is no explicit output for the function, but several output vectors can
be generated depending on the arguments and \textcolor{blue}{first->}, \textcolor{blue}{last->} and
\textcolor{blue}{expand->} options. The function prints the names of the output vectors generated.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 0- \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The variables whose class information is computed. Arguments
are not necessary if \textcolor{blue}{first->} and/or \textcolor{blue}{last->} are present.
Let §Arg be the generic name for arguments.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{class} \tabto{3cm} 1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  .oindent class \tabto{3cm} 1 \tabto{5cm}  REAL \tabto{7cm}
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{class} \tabto{3cm} 1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The variable indicating the class. The class variable which must be present in the data object or which is
an output variable of the \textcolor{blue}{trans->} transformations.
When the \textcolor{blue}{class->} variable, denoted as
as §Class changes,
the class changes.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{data} \tabto{3cm} 0|1 \tabto{5cm}  Data \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Data object used. Only one data object used; extra \textcolor{blue}{data->} objects just ignored. The default is the last
data object generated.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{expand} \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent If \textcolor{blue}{expand->} is present then the lengths output vectors are equal
to the number of observations in the data object and the values of the class variables
are repeated as many times as there are observations in each class. If
\textcolor{blue}{expand->} is not present, the lengths of the output vectors are.
equal to the number of classes.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{first} \tabto{3cm} 0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The the number of first observation in class is stored in vector
§Class\%\%first if \textcolor{blue}{expand->} is present and §Class\%first if \textcolor{blue}{expand->} is not present.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{last} \tabto{3cm} 0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The the number of lastt observation in class is stored in vector
§Class\%\%last if \textcolor{blue}{expand->} is present and §Class\%last if \textcolor{blue}{expand->} is not present.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{obsw} \tabto{3cm} 0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent If there axpnad-> option then vector Class\%\%obsw
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{ext} \tabto{3cm} -1|1 \tabto{5cm}  Char \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The extension to the names of vectors generated for arguments. Let
Ext be denote the extension.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{mean} \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The class means are stored in the vectors \newline
§Arg\#Class\%\%mean with \textcolor{blue}{expand->} and without \textcolor{blue}{ext->}\newline
§Arg\#Class\%\%meanExt with \textcolor{blue}{expand->} and with \textcolor{blue}{ext->} are \newline
§Arg\#Class\%mean without \textcolor{blue}{expand->} and without \textcolor{blue}{ext->} \newline
§Arg\#Class\%meanExt without \textcolor{blue}{expand->} and with \textcolor{blue}{ext->}
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{sd} \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Class standard deviations are computed to sd vectors
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{var} \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Class variances are computed to var vectors
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{min} \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Class minimums are computed to min vectors
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{max} \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Class maximums are computed to max vectors.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
Numbers of observations in each class can be obtained by \\
Class\%nobs=Class\%\%last-Class\%\%first+1 when \textcolor{blue}{expand->} is present, and \\
Class\%nobs=Class\%\%last-Class\%\%first+1
\end{note}
\begin{example}[newclassdata]Making class level data object\\
\label{newclassdata}
\textcolor{VioletRed}{classvector}(x1,x2,\textcolor{blue}{class->}stand,\textcolor{blue}{data->}treedata,\textcolor{blue}{mean->},\textcolor{blue}{min->})\\
standdata=\textcolor{VioletRed}{newdata}(x1\#stand\%mean,x2\#stand\%mean,x1\#stand\%min,x2\#stand\%min,\\
\textcolor{blue}{read->}(x1,x2,x1min,x2min))
\end{example}
\begin{example}[addingclass]Adding class means and deviations from class means\\
\label{addingclass}
\textcolor{VioletRed}{classvector}(x1,x2,\textcolor{blue}{class->}stand,\textcolor{blue}{data->}treedata,\textcolor{blue}{mean->},\textcolor{blue}{expand->})\\
tr=\textcolor{VioletRed}{trans}()\\
relx1=x1-x1mean\\
relx2=x2-x2mean\\
/\\
treedata=\textcolor{VioletRed}{newdata}(treedata,x1\#stand\%mean,x2\#stand\%mean,\textcolor{blue}{read->}(x1mean,x2mean),\\
\textcolor{blue}{maketrans->}tr)
\end{example}
\subsection{\textcolor{VioletRed}{stat}()}\index{stat()}
\label{stat}
Computes and prints basic statistics from data objects.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 0-1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  kokopo
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args  \tabto{3cm}  0-99 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent variables for which the statistics are computed,
the default is all variables in the data (all variables in the data matrix plus the output variables of the associated transformation object) and all output variables of the tran
@@data
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{data}  \tabto{3cm}  -1,99  \tabto{5cm}   Data  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent 	data objects , see section Common options for default\textcolor{green}{!\,weight\,	gives\,the\,weight\,of\,each\,observations\,if\,weighted\,means\,and\,variances\,are\,computed.\,The\,weigh}
transformation or it can be a variable in the data object
@@seecom
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{min}  \tabto{3cm}  -1,99 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent 	defines to which variables the minima are stored.
If the value is character constant or character variable,
then the name is formed by concatenating the character with the name of the argument
variable. E.g. \textcolor{VioletRed}{stat}(x1,x2,\textcolor{blue}{min->}'\%pien') stores minimums into variables
x1\%pien and x2\%pien. The default value for min  is '\%min'.
If the values of the \textcolor{blue}{min->} option are variables,
then the minima are stored into these variables.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{max}  \tabto{3cm} -1,99 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  maxima are stored, works as \textcolor{blue}{min->}
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{mean}  \tabto{3cm} -1,99 \tabto{5cm}  REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  means are stored
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{var}  \tabto{3cm} -1,99 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  variances are stored
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{sd}  \tabto{3cm} -1,99 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  standard deviations are stored
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{sum}  \tabto{3cm} -1,99 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent 	sums are stored, (note that sums are not printed automatically)
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{nobs}  \tabto{3cm} -1 | 1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent 	gives variable which will get the number of accepted observations, default is variable 'Nnobs'. If all observations are rejected due to \textcolor{blue}{filter->} or \textcolor{blue}{reject->} opt
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{trans}  \tabto{3cm} -1 | 1 \tabto{5cm}  TRANS \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent 	transformation object which is executed for each observation. If there is a transformation object associated with the data object, those transformations are
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{filter}  \tabto{3cm} -1 | 1 \tabto{5cm}  Code \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  logical or arithmetic statement (nonzero value indicating True) describing which observations will be accepted. \textcolor{blue}{trans->} transformations are computed before u
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{reject}  \tabto{3cm} -1 | 1 \tabto{5cm}  Code \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent \noindent reject  \tabto{3cm} -1 | 1 \tabto{5cm}  Code \tabto{7cm}
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent transafter  \tabto{3cm} -1 | 1 \tabto{5cm}   TRANS \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  transformation object which is executed for each observation which has passed the filter and is not rejected by the \textcolor{blue}{reject->}-option.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
1: \textcolor{VioletRed}{stat}() function prints min, max, means, sd and sd of the mean computed
as sd/\textcolor{VioletRed}{sqrt}(number of observations)
\end{note}
\begin{note}
2: If the value of a variable is greater than or equal to 1.7e19,
then that observation is rejected when computing statistics for that variable.
\end{note}
\begin{example}[statex]stat() computes minimums, maximums, means and std devaitons\\
\label{statex}
;if(\textcolor{VioletRed}{type}(data1).ne.DATA)dataex\\
\textcolor{VioletRed}{stat}()\\
\textcolor{VioletRed}{stat}(area,\textcolor{blue}{data->}cd,\textcolor{blue}{sum->}bon20,\textcolor{blue}{filter->}(site.ge.18.5))\\
\textcolor{VioletRed}{stat}(ba,\textcolor{blue}{data->}cd,\textcolor{blue}{weight->}area)\\
\textcolor{VioletRed}{stat}(vol,\textcolor{blue}{weight->}(1/dbh***2))
\end{example}
\subsection{\textcolor{VioletRed}{classify}()}\index{classify()}
\label{classify}
Classifies data with respect to one or two variables, get class
frequencies,
means and standard deviations of
argument variables.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}  Matrix \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent \noindent Output \tabto{3cm}  1 \tabto{5cm}  Matrix \tabto{7cm}
A matrix containing class information (details given below)
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 1- \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent \noindent Args \tabto{3cm} 1- \tabto{5cm}  REAL \tabto{7cm}
Variables for which class means are computed.
@@data
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{x}  \tabto{3cm} 1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The first variable defining classes.
minobs minimum number of observation in a class, obtained by merging classes. Does
not work if \textcolor{blue}{z->} is given
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{xrange} \tabto{3cm}  -1|0|2 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Defines the range of x variable. If \textcolor{blue}{xrange->} is given without
arguments and \textbf{J} variables x\%min and x\%max exist, they are used, and
if they do not exist an error occurs. Note that these variables can be
generate with \textcolor{VioletRed}{stat}(\textcolor{blue}{min->},\textcolor{blue}{max->}). Either xtrange-> or \textcolor{blue}{any->} must be presente.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{any} \tabto{3cm} -1|0 \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Indicates that each value of the x-variables foms a separate class.
either \textcolor{blue}{xrange->} or nay-> must be present.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{classes} \tabto{3cm} -1|1 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Number of classes, If \textcolor{blue}{dx->} is not given, the default is that range is
divided into 7 classes.
\textcolor{blue}{minobs->} minimum number of observations in one class. Classes are merged so that this can
be obtained. Does not work if \textcolor{blue}{z->} is present.
!
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{z} \tabto{3cm} -1|1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The second variable (z variable) defining classes in two dimensional classification.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{zrange}  \tabto{3cm} -1|0|2 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Defines the range and class width for a continuous z
variable. If \textbf{J} variables x\%min and x\%max exist,
provided by \textcolor{VioletRed}{stat}(\textcolor{blue}{min->},\textcolor{blue}{max->}), they are used.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{dz}  \tabto{3cm} -1|1 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Defines the class width for a continuous z variable.
mean if z variable is given, class means are stored in a matrix given in the \textcolor{blue}{mean->}
option
classes number of classes, has effect if dx is not defined in xrangedx->. The default is
\textcolor{blue}{classes->}7. If z is given then, there can be a second argument, which gives the
number of classes for z, the default being 7.
@@trans
@@filter
@@reject
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{print} \tabto{3cm} -1|1 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  By setting \textcolor{blue}{print->}0, the classification matrix is not printed.
The matrix can be utilized directly in \textcolor{VioletRed}{drawclass}() function.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
If z variable is not given then first column in printed output and the first row in the output
matrix (if given) contains class means of the x variable. In the output matrix the last element is
zero. Second column an TARKASTA VOISIKO VAIHTAArow shows number of observations in
class, and the last element is the total number of observations. Third row shows the class means
of the argument variable. The fourth row in the output matrix shows the class standard
deviations, and the last element is the overall standard deviation
\end{note}
\begin{note}
Variable Accepted gives the number of accepted obsevations.
\end{note}
\subsection{\textcolor{VioletRed}{class}()}\index{class()}
\label{class}
Function \textcolor{VioletRed}{class}() computes the the class of given value when classifying values
similarly as done in \textcolor{VioletRed}{classify}().
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 1 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The class number.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 1 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The value whose class is determined.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{xrange} \tabto{3cm} 2 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The range of values.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{dx} \tabto{3cm} N|1 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The class width.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{classes} \tabto{3cm} N|1 \tabto{5cm}  Real \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The number of classes.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
Either \textcolor{blue}{dx->} or \textcolor{blue}{classes->} must be given. If both are given, \textcolor{blue}{dx->} dominates.
\end{note}
\begin{note}
If \textcolor{VioletRed}{stat}() is used earlier for variables including Var1 and
options \textcolor{blue}{min->} and \textcolor{blue}{max->} are present, then
\textcolor{blue}{xrange->}(Var1\%min,Var1\%max) is assumed.
\end{note}
\subsection{Problem definition object}
\label{problemo}
Problem definition object is a compound object produced by the \textcolor{VioletRed}{problem}() function, and it is
described in Linear programming.
\subsection{Scatterplot: \textcolor{VioletRed}{plotyx}()}\index{plotyx()}
\label{plotyx}
\textcolor{VioletRed}{plotyx}() makes scatterplot.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output  \tabto{3cm}  1 \tabto{5cm}   FIGURE  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The FIGURE object created or updated.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args  \tabto{3cm}  1 | 2  \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  y and x-variable, if \textcolor{blue}{func->} is not present.
In case y-variable is given with \textcolor{blue}{func->}only,  x-variable is given as argument.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{data}  \tabto{3cm}  N | 1  \tabto{5cm}   DATA  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Data object used, default the last data object created or the dta given
with data=\textcolor{VioletRed}{list}().
@@figu
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{mark}  \tabto{3cm}  N | 1  \tabto{5cm}   REAL | CHAR  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The mark used in the plot. Numeric values refer to
mark types of Gnuplot. The mark can be given also as CHAR varible or constant.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{func} \tabto{3cm}  N | 1  \tabto{5cm}   Code  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent   Code option telling how the y-variable is computed.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[plotyxex]plotyx()\\
\label{plotyxex}
xmat=\textcolor{VioletRed}{matrix}(\textcolor{blue}{do->}(0,10,0.001))\\
tr=\textcolor{VioletRed}{trans}()\\
y=2+3*x+0.4*x*x+4*rann()\\
/\\
da=\textcolor{VioletRed}{newdata}(xmat,\textcolor{blue}{read->}x,\textcolor{blue}{maketrans->}tr,\textcolor{blue}{extra->}(Regf,Resid))\\
fi=\textcolor{VioletRed}{plotyx}(y,x)\\
fi=\textcolor{VioletRed}{plotyx}(x,\textcolor{blue}{func->}tr(y),\textcolor{blue}{mark->}3,\textcolor{blue}{color->}Orange)\\
reg=\textcolor{VioletRed}{regr}(y,x)\\
fi=\textcolor{VioletRed}{plotyx}(y,x,\textcolor{blue}{show->}0)\\
fi=\textcolor{VioletRed}{plotyx}(Regf,x,\textcolor{blue}{append->})\\
fir=\textcolor{VioletRed}{plotyx}(Resid,x)
\end{example}
\begin{note}
With data with integer values, the default ranges of Gnuplot may be hide point at
borderlines.
\end{note}
\begin{note}
\textcolor{teal}{fi}=\textcolor{VioletRed}{plotyx}() produces or updates file \textcolor{teal}{fi}.jfig] which contains
Gnuplot commands and file \textcolor{teal}{fi}.jfi0 containg data.
\end{note}
\subsection{Draw a function: \textcolor{VioletRed}{draw}()}\index{draw()}
\label{draw}
\textcolor{VioletRed}{draw}() draws a function.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output  \tabto{3cm}  1 \tabto{5cm}   FIGURE  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The FIGURE object created or updated.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{func} \tabto{3cm}  N | 1  \tabto{5cm}   Code  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent   Code option telling how the y-variable is computed.
@@draw
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{mark}  \tabto{3cm}  N | 1  \tabto{5cm}   REAL | CHAR  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The mark used in the plot.
Numeric values refer to.
mark types of Gnuplot. The mark can be given also as CHAR varible or constant.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{width}  \tabto{3cm}  0 | 1  \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  the width of the line
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[drawex]Example of \textcolor{VioletRed}{draw}()\\
\label{drawex}
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}\textcolor{VioletRed}{sin}(x),\textcolor{blue}{xrange->}(0,2*Pi),\textcolor{blue}{color->}Blue,Continue->)\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}\textcolor{VioletRed}{cos}(x),\textcolor{blue}{xrange->}(0,2*Pi),\textcolor{blue}{color->}Red,\textcolor{blue}{append->})\\
\textcolor{VioletRed}{if}(\textcolor{VioletRed}{type}(figyx).ne.FIGURE)plotyxex\\
\textcolor{VioletRed}{show}(figyx)\\
reg0=\textcolor{VioletRed}{regr}(y,x)\\
\textcolor{VioletRed}{stat}(\textcolor{blue}{data->}datyx,\textcolor{blue}{min->},\textcolor{blue}{max->})\\
figyx=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}reg0(),\textcolor{blue}{x->}x,\textcolor{blue}{xrange->},\textcolor{blue}{color->}Violet,\textcolor{blue}{append->})\\
tr=\textcolor{VioletRed}{trans}()\\
x2=x*x\\
fu=reg2()\\
/\\
reg2=\textcolor{VioletRed}{regr}(y,x,x2,\textcolor{blue}{data->}datyx,\textcolor{blue}{trans->}tr)\\
figyx=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}tr(fu),\textcolor{blue}{xrange->},\textcolor{blue}{color->}Orange,\textcolor{blue}{append->})\\
Continue=1 \,\textcolor{green}{!Errors}\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}\textcolor{VioletRed}{sin}(x),\textcolor{blue}{x->}x)\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{xrange->}(1,100),\textcolor{blue}{func->}Sin(x),\textcolor{blue}{x->}x)\\
Continue=0
\end{example}
\begin{note}
\textcolor{teal}{fi}=\textcolor{VioletRed}{draw}() produces or updates file \textcolor{teal}{fi}.jfig] which contains
Gnuplot commands and file \textcolor{teal}{fi}.jfi0 containg data.
\end{note}
\subsection{Draw values in a matrix generated with \textcolor{VioletRed}{classify}(): \textc}\index{classify()drawclass()}
\label{drawclass}
\textcolor{VioletRed}{drawclass}() can plot class means and/or lines connecting class means, with
or without standard errors of class means, within class standard deviations,
within class variances, frequency histograms, which can be scaled so that
density funtions can be drawn in the same figure.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output  \tabto{3cm} 1  \tabto{5cm}   FIGURE  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  FIGURE object updated or generated.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Arg  \tabto{3cm}  1 \tabto{5cm}   MATRIX  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  A MATRIX generated with \textcolor{VioletRed}{classify}().
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{se}  \tabto{3cm}  N | 0  \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Presence of option tells to include that error bars showing standard errors
of class means computed as \textcolor{VioletRed}{sqrt}(sample\_within-class\_variance)/number\_of\_obs)
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{sd}  \tabto{3cm}  N | 0  \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Within-calss standard deviations are drawn.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{var}  \tabto{3cm}  N | 0  \tabto{5cm}     \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Within-class sample variances are drawn.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent histo  \tabto{3cm}   N | 0  \tabto{5cm}     \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Within-class sample variances are drawn.abto{5cm}
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{freq}  \tabto{3cm}  N | 0  \tabto{5cm}     \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent Cumulative  frequences are drawn.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{area}  \tabto{3cm}  N |0  \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent the histogram is scaled so that that it can be overlayed to density function
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[drawclassex]Examples of \textcolor{VioletRed}{drawclass}()\\
\label{drawclassex}
X=\textcolor{VioletRed}{matrix}(\textcolor{blue}{do->}(1,100,0.1))\\
e=\textcolor{VioletRed}{matrix}(\textcolor{VioletRed}{nrows}(X))\\
e=\textcolor{VioletRed}{rann}()\\
X2=0.01*x*.x \textcolor{green}{!elementwise\,product}\\
Y=2*x+0.01*X2+(1+0.3*X)*.e \,\textcolor{green}{!nonequal\,error\,variance,quadratic\,function}\\
dat=\textcolor{VioletRed}{newdata}(x,y,x2,\textcolor{blue}{read->}(x,y,x2),\textcolor{blue}{extra->}(Regf,Resid))\\
\textcolor{VioletRed}{stat}(\textcolor{blue}{min->},\textcolor{blue}{max->})\\
reg=\textcolor{VioletRed}{regr}(y,x) \textcolor{green}{!\,Regf\,and\,resid\,are\,put\,into\,the\,data}\\
fi=\textcolor{VioletRed}{plotyx}(y,x)\\
fi=\textcolor{VioletRed}{drawline}(x\%min,x\%max,reg(x\%min),reg(x\%max),\textcolor{blue}{width->}3,\textcolor{blue}{color->}Cyan,\textcolor{blue}{append->})\\
cl=\textcolor{VioletRed}{classify}(Resid,\textcolor{blue}{x->}x,\textcolor{blue}{xrange->},\textcolor{blue}{classes->}5)\\
fi=\textcolor{VioletRed}{drawclass}(cl,\textcolor{blue}{color->}Blue)\\
fi=\textcolor{VioletRed}{drawclass}(cl,\textcolor{blue}{se->})\\
fi=\textcolor{VioletRed}{drawclass}(cl,\textcolor{blue}{sd->})\\
fi=\textcolor{VioletRed}{drawclass}(cl,\textcolor{blue}{var->})\\
fi=\textcolor{VioletRed}{drawclass}(cl,histo->,\textcolor{blue}{area->})\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}\textcolor{VioletRed}{pdf}(0,\textcolor{VioletRed}{rmse}(reg)),\textcolor{blue}{x->}x,\textcolor{blue}{xrange->},\textcolor{blue}{append->}) \textcolor{green}{!\,xrange\,comes\,from\,\textcolor{VioletRed}{stat}()}
\end{example}
\begin{note}
In previous versions of \textbf{J} if \textcolor{blue}{se->} and \textcolor{blue}{sd->} were both present, the error
bot bars were plotted. This possibility will be included later.
\end{note}
\subsection{Draw a polygon through points: \textcolor{VioletRed}{drawline}()}\index{drawline()}
\label{drawline}
\textcolor{VioletRed}{drawline}() draws a function through points.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output  \tabto{3cm}  1 \tabto{5cm}   FIGURE  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The FIGURE object created or updated.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 1-  \tabto{5cm}  REAL | MATRIX  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The points which are connected:
\begin{itemize}
\item[\textbf{J}\.] x1,...,xn,y1,...,yn The x-coordinates and y-coordinates,
\$n \geq 1\$
\item[\textbf{J}\.]  If there is only one argument which is a
matrix object having two rows, then the first row is assumed to give the x values
and the second row the y values.
\item[\textbf{J}\.]  If there are two matrix (vector) arguments, then
the first matrix gives the x-values and the second matrix gives the y-values.
It does not matter if arguments are row or column vectors.
\end{itemize}
@@figure
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{label}  \tabto{3cm}  N | 1  \tabto{5cm}   CHAR  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Label written to the end of line. If arguments define only one point,
then with \textcolor{blue}{label->} option one can write text to any point.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{mark}  \tabto{3cm}  N | 1  \tabto{5cm}   REAL | CHAR  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The mark used in the plot.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{break}  \tabto{3cm}  N | 0  \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The line is broken when a x-value is smaller than the previous one.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{set}  \tabto{3cm}  N|1  \tabto{5cm}   REAL<6  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Set to which lines are put. If the option is not present,
then a separate Gnuplot plot command with possible color and width information
is generated for each \textcolor{VioletRed}{drawline}() and data points are stored
in file \textcolor{teal}{fi}.jfi0, i.e. the same file used by \textcolor{VioletRed}{plotyx}().
If set is given e.g as \textcolor{blue}{set->}3, then it is possible to plot a large number of lines
with the same width and color. The data points are stored into file \textcolor{teal}{fi}.jfi3. This is
useful e.g. when drawing figures showing transportation of timber to factories
for huge number of sample plots.
Numeric values refer to Gnuplot mar types.
The mark can be given also as CHAR varible or constant.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{width}  \tabto{3cm}  0 | 1  \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  the width of the line. Default: \textcolor{blue}{width->}1
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{label} \tabto{3cm}  N |1  \tabto{5cm}  CHAR  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Text plotted to the end of line.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[drawlineex]Example of \textcolor{VioletRed}{drawline}()\\
\label{drawlineex}
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}\textcolor{VioletRed}{sin}(x),\textcolor{blue}{xrange->}(0,2*Pi),\textcolor{blue}{color->}Blue,Continue->)\\
fi=\textcolor{VioletRed}{drawline}(Pi,\textcolor{VioletRed}{sin}(Pi)+0.1,\textcolor{blue}{label->}'\textcolor{VioletRed}{sin}()',\textcolor{blue}{append->})\\
xval=\textcolor{VioletRed}{matrix}(\textcolor{blue}{do->}(1,100))\\
mat=\textcolor{VioletRed}{matrix}(\textcolor{blue}{values->}(xval,xval+1,xval,xval+2,xval,xval+3))\\
fi=\textcolor{VioletRed}{drawline}(mat,\textcolor{blue}{color->}Red)\\
fi=\textcolor{VioletRed}{drawline}(mat,break,\textcolor{blue}{color->}Orange,\textcolor{blue}{break->})\\
x=\textcolor{VioletRed}{matrix}(\textcolor{blue}{do->}(0,100,1)\\
e=\textcolor{VioletRed}{matrix}(101)\\
e=\textcolor{VioletRed}{rann}()\\
y=2*x+0.4+e\\
da=\textcolor{VioletRed}{newdata}(x,y,\textcolor{blue}{read->}(x,y))\\
reg=\textcolor{VioletRed}{regr}(y,x)\\
fi=\textcolor{VioletRed}{drawline}(\\
\textcolor{VioletRed}{if}(\textcolor{VioletRed}{type}(figyx).ne.FIGURE)plotyxex\\
\textcolor{VioletRed}{show}(figyx)\\
reg0=\textcolor{VioletRed}{regr}(y,x)\\
\textcolor{VioletRed}{stat}(\textcolor{blue}{data->}datyx,\textcolor{blue}{min->},\textcolor{blue}{max->})\\
figyx=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}reg0(),\textcolor{blue}{x->}x,\textcolor{blue}{xrange->},\textcolor{blue}{color->}Violet,\textcolor{blue}{append->})\\
tr=\textcolor{VioletRed}{trans}()\\
x2=x*x\\
fu=reg2()\\
/\\
reg2=\textcolor{VioletRed}{regr}(y,x,x2,\textcolor{blue}{data->}datyx,\textcolor{blue}{trans->}tr)\\
figyx=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}tr(fu),\textcolor{blue}{xrange->},\textcolor{blue}{color->}Orange,\textcolor{blue}{append->})\\
Continue=1 \,\textcolor{green}{!Errors}\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}\textcolor{VioletRed}{sin}(x),\textcolor{blue}{x->}x)\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{xrange->}(1,100),\textcolor{blue}{func->}Sin(x),\textcolor{blue}{x->}x)\\
Continue=0
\end{example}
\begin{note}
if a line is not visible, this may be caused by the fact that
the starting or ending point is outside the range specified by \textcolor{blue}{xrange->} or \textcolor{blue}{yrange->}.
\end{note}
\subsection{Show figure: \textcolor{VioletRed}{show}()}\index{show()}
\label{show}
An figure stored in a figure object or in Gnuplot file can be plotted. If the
argument is FIGURE, the
parameters of the figure can be changed. If the argument is the name of
Gnuplot file, the file must be edited.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args  \tabto{3cm}  1 \tabto{5cm}   FIGURE | CHAR  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The figure object or the name of the file containg Gnuplot commans,
@@figure
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
If the argument is the file name with .jfig extension, and you edit the file, its is safe to change the name,
becase if an figure with teh same name is generated, the edited fike is autimatically
deleted. If the file refers other files, it is wise to rename also these files and change
the names in the beginning of the .jfig file.
\end{note}
\begin{note}
You may wish to use show also if you cnange the window size
\end{note}
\begin{example}[showex]Example of \textcolor{VioletRed}{show}()\\
\label{showex}
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}\textcolor{VioletRed}{sqrt2}(x),\textcolor{blue}{x->}x,\textcolor{blue}{xrange->}(-50,50))\\
\textcolor{VioletRed}{show}(fi,\textcolor{blue}{xrange->}(-60,60),\textcolor{blue}{xlabel->}'NEWX',\textcolor{blue}{ylabel->}'NEWY')\\
\textcolor{VioletRed}{show}(fi,\textcolor{blue}{axes->}10)\\
\textcolor{VioletRed}{show}(fi,\textcolor{blue}{axes->}01)\\
\textcolor{VioletRed}{show}(fi(\textcolor{blue}{axes->}00)\\
Window='400,800'\\
\textcolor{VioletRed}{show}(fi)\\
Window='700,700'\\
fi=\textcolor{VioletRed}{drawline}(1,10,3,1,\textcolor{blue}{color->}Red)\\
\textcolor{VioletRed}{show}(fi,\textcolor{blue}{xrange->}(1.1,11)) \textcolor{green}{!the\,line\,is\,not\,visible}\\
dat=\textcolor{VioletRed}{data}(\textcolor{blue}{read->}(x,y),\textcolor{blue}{in->})\\
1,4\\
2,6\\
3,2\\
5,1\\
/\\
\textcolor{VioletRed}{stat}()\\
fi=\textcolor{VioletRed}{plotyx}(y,x) \,\textcolor{green}{!\,Gnuplot\,hides\,points\,at\,border}\\
\textcolor{VioletRed}{show}(fi,\textcolor{blue}{xrange->}(0,6),\textcolor{blue}{yrange->}(0,7))
\end{example}
\subsection{Plot 3d-figure: \textcolor{VioletRed}{plot3d}()}\index{plot3d()}
\label{plot3d}
Plot 3d-figure with indicater contours  with colours.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output  \tabto{3cm}  1   \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  \textcolor{teal}{fi}=\textcolor{VioletRed}{plot3d}() generates Gnuplot file \textcolor{teal}{fi}.jfig.
No figure object is produced.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm}  1  \tabto{5cm}   MATRIX  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The argument is a matrix having 3 columns for x,y and z.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{sorted}  \tabto{3cm}  N | 1  \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent \textcolor{VioletRed}{plot3d}() uses the Gnuplot function splot, which requires that the data
is sorted withe respect to the x-variable. \textcolor{blue}{sorted->} indicates that the argument matrix is sorted
either natrurally or with \textcolor{VioletRed}{sort}() function. If \textcolor{blue}{sort->} is not presented, plot3
sorts the data.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[plot3dex]plot3d() example see p.  328 in Mehtatalo & Lappi 2020\\
\label{plot3dex}
mat=\textcolor{VioletRed}{matrix}(1000000,3)\\
mat2=\textcolor{VioletRed}{matrix}(1000000,3)\\
tr=\textcolor{VioletRed}{trans}() \textcolor{green}{!second\,order\,response\,surface}\\
x=0\\
x2=0\\
xy=0\\
irow=1\\
\textcolor{VioletRed}{do}(ix,1,1000)\\
y=0\\
y2=0\\
xy=0\\
\textcolor{VioletRed}{do}(iy,1,1000)\\
mat(irow,1)=x\\
mat(irow,2)=y\\
mat(irow,3)=12+8*x-7*x2+124*y+8*xy-13*y2\\
mat2(irow,1)=x\\
mat2(irow,2)=y\\
mat2(irow,3)=50+160*x-5*x2-40*y-20*xy+10*y2\\
irow=irow+1\\
y=y+0.01\\
y2=y*y\\
xy=x*y\\
enddo\\
x=x+0.01\\
x2=x*x\\
enddo\\
/\\
\textcolor{VioletRed}{call}(tr)\\
fi=\textcolor{VioletRed}{plot3d}(mat,\textcolor{blue}{sorted->})\\
fi=\textcolor{VioletRed}{plot3d}(mat2,\textcolor{blue}{sorted->})
\end{example}
\subsection{Bitmatrix}
\label{bitmatrixo}
A BITMATRIX is an object which can store in small memory space large matrices
used to indicate logical values. A BITMATRIX object is produced by \textcolor{VioletRed}{bitmatrix}()
function or by closures() function from an existing bitmatrix. Bitmatrix values
can be read from the input stream or file or set by setvalue() function. The
values of bitmatrix elements can be accessed with value() function.
\begin{note}
Also ordinary real variable can be used to store bits. See bit functions.
\end{note}
\subsection{Object names}
\label{onames}
Object names start with letter or with '\$'. Object names can contain any of
symbols '\#.\%§$\backslash$\_'. \textbf{J} is using '\%' to name objects related to some other objects.
E.g. function \textcolor{VioletRed}{stat}(x1,x2,\textcolor{blue}{mean->}) will store means of variables x1 and x2 into
variables x1\%mean and x2\%mean. Objects with name starting with '\$' are not
stored in the automatically created lists of input and output variables when
defining transformation objects. The variable Result which
is the output variable, if no output is given, is not put into these lists.
Object names can contain special characters (e.g. +-*=()) if these are closed
within ‘[‘ and ‘]’, e.g. a[2+3]. This possibility to include additional information
is borrowed from Markku Siitonen, the developer of Mela software.
If an transformation object is created with \textcolor{VioletRed}{trans}() function, and the
intended global arguments are given in the list of arguments,
then a  local object {ob} created e.g. with transformation object {tr} have prefix
{tr$\backslash$} yelding {tr\textcolor{green}{!\ob}.\,Actually\,also\,these\,objects\,are\,global,\,but\,their\,prefix}
protects them so that they do not intervene with objects having the same name in the
calling transformation objec.
There are many objects intitilized automatically.
Some of these are locked so that the users cannot change them.
Names of objects having a predefined interpretation start with capital letter.
The user can freely use lower or upper case letters. \textbf{J} is case sensitive.
All objects known at a given point of a \textbf{J} session can be listed by command:
\textcolor{VioletRed}{print}(Names)
\subsection{Copying object: a=b}
\label{copy}
A copy of object can be made by the assignment statement a=b.
\subsection{Deleting objects: delete\_o()}
\label{delete}
When an object with a given name is created, the name cannot be removed. With
delete\_0() function one can free all memory allocated for data structures needed
by general objects:
delete\_o(obj1,…,objn)
After deleting an object, the name refers to a real variable (which is
initialized by the delete\_o() function into zero).
\begin{note}
Other objects except matrices can equivalently be deleted by giving
command
obj1,…,objn = 0
This is because the output objects of any functions are first deleted before
defining them anew. Usually an object is automatically deleted if the object
name is as an output object for other functions.
\end{note}
\begin{note}
One can see how much memory each object is using \textcolor{VioletRed}{print}(Names).mes
\end{note}
\begin{note}
Deleting a compound object deletes also such
subobjects which have no meaning when the main object is deleted. But e.g. if a
data object is deleted then the as-sociated transformation object is not
deleted as the transformation can be used independently.
\end{note}
\begin{note}
Files can be deleted with delete\_f(file). See IO-functions for
details.
\end{note}
\begin{note}
If the user has defined own new compound objects in the open source
\textbf{J} software she/he needs to define the associated delete function.
\end{note}
\subsection{Object types}
\label{otypes}
The following description describes shortly different object types available in
\textbf{J}. More detailed descriptions are given in connection of \textbf{J} functions which
create the objects and in Developers' guide.
\subsubsection{Real variables and constants}
\label{realo}
A REAL variable is a named object associated with a single
double precision value. Before version J3.0 the values were in single
precision, and thus this objecttype is still called REAL.
The
value can be directly defined at the command level, or the variable can get
the value from data structures.  E.g.
\\
\textcolor{VioletRed}{stat}(D,H,\textcolor{blue}{min->},\textcolor{blue}{max->}) &\textcolor{green}{!\,Here\,arguments\,must\,be\,variable\,names}
\\
\\
a = \textcolor{VioletRed}{sin}(2.4) &\textcolor{green}{!\,argument\,is\,in\,radians\,\textcolor{VioletRed}{sind}()\,is\,for\,degrees}
\\
h = \textcolor{VioletRed}{data}(\textcolor{blue}{read->}(x1…x4))  & \textcolor{green}{!\,x1,\,x2\,,x3,\,x4\,are\,variables\,in\,the\,data\,set,\,and}
\\
get their values when doing operations for the data.
\\
\begin{note}
All objects have also an associated REAL value. In order to make
arithmetic operations fast, the argument types in simple arithmetic functions
are not checked. If a general object is used as an argument in an arithmetic
operation, then the REAL value associated with the object is used. This will
usually prevent the program to stop due to Fortran errors, but will produce
unintended results.
\end{note}
\begin{note}
In this manual 'variable' refers to a \textbf{J} object whose type is REAL.
\end{note}
\subsubsection{Character constants and variables}
\label{charo}
Character constants are generated by closing text within apostrophe signs ( '
). Apostrophe character ( ' ) within a character constant is indicated with ($\sim$)
(if the character $\sim$\,is\,not\,present\,in\,the\,keyboard,\,it\,can\,be\,produced\,by\,<Alt
>126, where numbers are entered from the numeric keyboard) Character constants are used e.g.  in I/O functions for file names, formats
and to define text to be written.  , e.g
\\
a = \textcolor{VioletRed}{data}(\textcolor{blue}{in->}'file1.dat', \textcolor{blue}{read->}(x1,x2)) &
\\
\\
\textcolor{VioletRed}{write}('output.txt', '($\sim$kukkuu=$\sim$,4f7.0)', \textcolor{VioletRed}{sqrt}(a)) &
\\
Character variables are pointers to character constants. An example of a
character variable definition:
\\
cvar='file1.dat' &
\\
After defining a character variable, it can be used exactly as the character
constants.
\begin{note}
The quotation mark (") has special meaning in the input programming. See
Input programming how to use character constants within character constants.
\end{note}
\subsubsection{Logical values}
\label{logical0}
There is no special object type for logical variables. Results of logical
operations are stored into temporary or named real variables so that 0 means
False and 1 means True. In logical tests all non-zero values will mean True.
Thus e.g. \textcolor{VioletRed}{if}(6)b=7 is legal statement, and variable b will get value 7. E.g.
\\
\textcolor{Red}{sit>}h=a.lt.b.and.b.le.8 &
\\
\textcolor{Red}{sit>}\textcolor{VioletRed}{print}(h) &
\\
h=   1.00000 &
\\
\subsection{Predefined objects}
\label{pref}
The following objects are generated during the initilaization.

\noindent \textcolor{teal}{Names} \tabto{25mm }   Text \tabto{45mm }   Text object containg the names of named objects

\noindent \textcolor{teal}{Pi} \tabto{25mm }  REAL \tabto{45mm }  The value of Pi (=3.1415926535897931)

\noindent \$\textcolor{teal}{Cursor}\$ \tabto{25mm }   TRANS  \tabto{45mm }   The transformation object used to run \textcolor{Red}{sit>} prompt

\noindent \$\textcolor{teal}{Cursor2}\$ \tabto{25mm }   TRANS  \tabto{45mm }   Another transformation object used to run \\
\tabto{45mm } \textcolor{Red}{sit>} prompt

\noindent \textcolor{teal}{Val} \tabto{25mm }  TRANS \tabto{45mm }   Transformation object used to extract values of mathematical statements, used,

\noindent \textcolor{teal}{Round}  \tabto{25mm }  REAL \tabto{45mm }   \textcolor{VioletRed}{jlp}(): The current round through treatment units in \textcolor{VioletRed}{jlp}() function.

\noindent \textcolor{teal}{Change} \tabto{25mm }  REAL \tabto{45mm }   \textcolor{VioletRed}{jlp}(): The change of objective in \textcolor{VioletRed}{jlp}()  in one round before finding feasible and thereafter

\noindent \textcolor{teal}{Imp} \tabto{25mm }  REAL \tabto{45mm }   \textcolor{VioletRed}{jlp}(): The number of improvements obtained from schedules outside the current active

\noindent \$\textcolor{teal}{Data}\$  \tabto{25mm }   List \tabto{45mm }   Default data set name for a new data set created by \textcolor{VioletRed}{data}()-function.

\noindent \textcolor{teal}{Obs} \tabto{25mm }   REAL  \tabto{45mm }   The default name of variable obtaining the the number of

\noindent \textcolor{teal}{Maxnamed}  \tabto{25mm }  REAL \tabto{45mm }   The maximum number of named objects. Determined via j.par in

\noindent \textcolor{teal}{Record} \tabto{25mm }   REAL  \tabto{45mm }   The name of variable obtaining the the number of

\noindent \textcolor{teal}{Subecord} \tabto{25mm }   REAL  \tabto{45mm }   The name of variable obtaining the the number of

\noindent \textcolor{teal}{Duplicate} \tabto{25mm }   REAL \tabto{45mm }   A special variable used in \textcolor{VioletRed}{data}() function when duplicating observations

\noindent \textcolor{teal}{LastaData}  \tabto{25mm }  List \tabto{45mm }  	A list object referring to the last data set made, used as default data set.

\noindent \$\textcolor{teal}{Buffer} \tabto{25mm }  Char \tabto{45mm }   A special character object used by the \textcolor{VioletRed}{write}() function.

\noindent \$\textcolor{teal}{Input}\$ \tabto{25mm }   Text  \tabto{45mm }   Text object used for original input line.

\noindent \textcolor{teal}{1}\$Input1\$  \tabto{25mm }  Text \tabto{45mm }   Text object for input line after removing blanks and comments.

\noindent \textcolor{teal}{Data}  \tabto{25mm }  List \tabto{45mm }    List object used to indicate current data setsDat

\noindent \$ \\textcolor{teal}{tabto{25mm} }  REAL \tabto{45mm }   Object name used to indicate console and '*' format in reading and writing

\noindent \textcolor{teal}{x}\# \tabto{25mm }  REAL \tabto{45mm }   Variable used when drawing functions.

\noindent \textcolor{teal}{Selected} \tabto{25mm }   REAL  \tabto{45mm }  Variable used to indicate the simulator selected in simulations

\noindent \textcolor{teal}{Printinput} \tabto{25mm }   REAL \tabto{45mm }   Variable used to specify how input lines are printed. Not properly used.

\noindent \textcolor{teal}{Prinoutpu} \tabto{25mm }   REAL \tabto{45mm }   Variable used to indicate how much output is printed. Not properly used.

\noindent \$\textcolor{teal}{Debug} \tabto{25mm }  REAL \tabto{45mm }   Variable used to put debugging mode on.

\noindent \textcolor{teal}{Accepted}  \tabto{25mm }  REAL \tabto{45mm }   The number of accepted observations in functions using data sets.

\noindent \textcolor{teal}{Arg} \tabto{25mm }   REAL  \tabto{45mm }   The default argument name when using transformation object as a function.

\noindent \textcolor{teal}{Continue}  \tabto{25mm }  REAL \tabto{45mm }   If Continue has nonzero value then the control does not return to the

\noindent \textcolor{teal}{Err} \tabto{25mm }  REAL \tabto{45mm }   If Continue prevents the control from returning to \textcolor{Red}{sit>} prompt

\noindent \textcolor{teal}{Result} \tabto{25mm }   ?  \tabto{45mm }   The default name of output object.

\subsubsection{Transformation object}
\label{transo}
A transformation object groups several operation commands together so that they
can be used for different purposes by \textbf{J} functions and \textbf{J} objects. A
transformation object contains the interpreted transformations. For more details
see \textbf{J} function for defining transformation objects: \textcolor{VioletRed}{trans}().
Transformation objects can be called using \textcolor{VioletRed}{call}() function, so that all
transformations defined in the object are done once. Function result() also calls
transformations but is also returning a value. When transformation objects are
linked to data objects, then the transformations defined in trans-formation object
are done separately for each observation.
There is an implicit transformation object \$Cursor\$ which is used to run the
command level. The name \$Cursor\$ may appear in error messages when doing
commands at command level.  An-other transformation object \$Val\$ which is used to
take care of the substitutions of "-sequences in the input programming. Some \textbf{J}
functions use also implicitly transformations object \$Cursor2\$.
\subsubsection{Simulator}
\label{simulatoro}
A simulator is a transformation object with a few additional parameters. The
simulator is described in the Simulator chapter.
\subsection{Code options}
\label{codeopt}
There are some special options which do not refer to object names or values. Some options
define a small one-statement transformations to be used to compute something repeatedly.
As these one-statement can use transformation objects as functions, the code option can actually
execute long computations.
\begin{example}[codeoptex]Codeoptions\\
\label{codeoptex}
dat=\textcolor{VioletRed}{data}(\textcolor{blue}{read->}(D,H),\textcolor{blue}{in->})\\
3,2\\
2,4\\
4,1\\
/\\
\textcolor{VioletRed}{stat}(D,H,\textcolor{blue}{filter->}(H.gt.D)) \textcolor{green}{!\,only\,those\,observations\,are\,accepted\,which\,pass\,the\,filter}\\
fi=\textcolor{VioletRed}{draw}(\textcolor{blue}{func->}(\textcolor{VioletRed}{sin}(\$x)+1),\textcolor{blue}{x->}\$x,\textcolor{blue}{xrange->}(0,10),\textcolor{blue}{color->}Red,\textcolor{blue}{ylabel->}'\textcolor{VioletRed}{sin}(x)+1',\textcolor{blue}{xlabel->}'x',\textcolor{blue}{width->}2) \textcolor{green}{!\,the\,\textcolor{blue}{func->}\,option\,transmits\,the\,function\,to\,be\,drawn\,not
\end{example}
\subsection{Common options}
\label{comoptions}
There are some options which are used in many \textbf{J} functions. Such options are e.g.
@@in2
@@data
All data sets will be
treated logically as a single data set.
If the function is using data sets, the daenta sets are given in \textcolor{blue}{data->} option. All data sets will be
treated logically as a single data set. If a \textbf{J} function needs to access data, and the \textcolor{blue}{data->}
option is not given then \textbf{J} uses default data which is determined as follows.
If the user has defined an object list Data consisting of one or more data sets, then these will
be used as the default data set. E.g.
Data=\textcolor{VioletRed}{list}(dataa,datab)
When a data set is created, it will automatically become the only element in LastData list. If
the Data list has not been defined and there is no \textcolor{blue}{data->} option, then the LastData dataset
will be used.
@@trans
In all functions which are using data sets, \textcolor{blue}{trans->} option defines a
transformation set which is used in this function.
@@filter
\hline
\vspace{0.2cm}
\begin{example}[comopt]data1\\
\label{comopt}
tr=\textcolor{VioletRed}{trans}()\\
xy=x*y\\
/\\
\textcolor{VioletRed}{stat}(xy,\textcolor{blue}{trans->}tr)
\end{example}
\subsection{Excuting transformation object explicitly \textcolor{VioletRed}{call}()}\index{call()}
\label{call}
Interpreted transformations in a transformation object can be automatically executed by other \textbf{J}
functions or they can be executed explicitly using \textcolor{VioletRed}{call}() function.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Arg \tabto{3cm} 1 \tabto{5cm}  TRANS \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The transformation object executed.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
A transformation objects can be used recursively, i.e. a transformation can be called from
itself. The depth of recursion is not controlled by J, so going too deep in recursion will
eventually lead to a system error.
\end{note}
\begin{example}[recursion]Recursion produces system crash.\\
\label{recursion}
tr=\textcolor{VioletRed}{trans}() \textcolor{green}{!level\,will\,be\,initialized\,as\,zero}\\
level;\\
level=level+1\\
\textcolor{VioletRed}{call}(tr)\\
/
\end{example}
\subsection{\textbf{J} transformations}
\label{jtrans}
Most operation commands affecting \textbf{J} objects can be entered directly at the command level or
packed into transformation object. In both cases the syntax and working is the same. A
command line can define arithmetic operations for real variables or matrices, or they can
include functions which operate on other \textbf{J} objects. General \textbf{J} functions can have arithmetic
statements in their arguments or in the option values. In some cases the arguments must be
object names. In principle it is possible to combine several general \textbf{J} functions in the same
operation command line, but there may not be any useful applications yet, and possibly some
error conditions would be generated.
Definition: A numeric function is a \textbf{J} function which returns a single real value. These functions
can be used within other transformations similarly as ordinary arithmetic functions. E.g.
\textcolor{VioletRed}{weights}() is a numeric function returning the number of schedules having nonzero weight
in a JLP-solution. Then \textcolor{VioletRed}{print}(\textcolor{VioletRed}{sqrt}(\textcolor{VioletRed}{weights}())+Pi) is a legal transformation.
\subsection{Generating a transformation object \textcolor{VioletRed}{trans}()}\index{trans()}
\label{trans}
\textcolor{VioletRed}{trans}() function interprets lines from input paragraph following the \textcolor{VioletRed}{trans}() command and puts the
interpreted code into an integer vector, which can be excuted in several places.
If there are no arguments in the function, the all objected used within the
transforamations are global. This may cause conflicts if there are several recursive
functions operating at the same time with same objects. \textbf{J} checks some of
these conflict situations, but not all.  These conflicts can be avoided by giving
intended global arguments  in the list of arguments.
Then an object 'ob' created e.g. with transformation object \textcolor{teal}{tr} have prefix
]tr$\backslash$[ yelding ]tr$\backslash$ob[. Actually also these objects are global, but their prefix
protects them so that they do not intervene with objects having the same name in the
calling transformation objec.
Each line in the input paragraph is read and interpreted and packed into a transformation
object, and associated tr\%input and tr\%output lists are created for input and output
variables. Objects can be in both lists. Objects having names starting
with '\$' are not put into the input or output lists. The source code is saved in a text object
tr\%source. List tr\%arg contains all arguments.
!
If a semicolon ';'  is at the end of an input line, then
the output is printed if REAL variable Prindebug has value 1 or value>2 at
the execution time. If the double semicolon ';;' is at the end then the output is
printed if Printresult>1. If there is no output, but just list of objects, then these
objects will be printed with semicolns.
!
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm} 1 \tabto{5cm}  Data \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The TRANS object generated.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} N|1- \tabto{5cm}    \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  Global objects.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
Options \textcolor{blue}{input->}, \textcolor{blue}{local->}, \textcolor{blue}{matrix->}, \textcolor{blue}{arg->}, \textcolor{blue}{result->}, \textcolor{blue}{source->} of previous
versions are obsolte.
\end{note}
\begin{note}
The user can intervene the execution from console if the code calls \textcolor{VioletRed}{read}(\$,),
\textcolor{VioletRed}{ask}(), \textcolor{VioletRed}{askc}() or \textcolor{VioletRed}{pause}() functions. During the pause one can give any command excepts
such input programming command as \textcolor{Red}{;incl}.
\end{note}
\begin{note}
The value of Printresult can be changed in other parts of the transformation, or
in other transforamations called or during execution of \textcolor{VioletRed}{pause}().
\end{note}
\begin{note}
Output variables in \textcolor{blue}{maketrans->} transformations whose name start with \$ are not put into the new data object.
\end{note}
\begin{example}[transex]Demonstrates also error handling\\
\label{transex}
tr=\textcolor{VioletRed}{trans}()\\
\$x3=x1+3\\
x2=2/\$x3;\\
/\\
tr\%input,tr\%output,tr\%source;\\
x1=8\\
\textcolor{VioletRed}{call}(tr)\\
tr2=\textcolor{VioletRed}{trans}(x1,x2)\\
\$x3=x1+3\\
x2=2/\$x3;\\
x3=x1+x2+\$x3;\\
/\\
tr2\%input,tr2\%output,tr2\%source;\\
\textcolor{VioletRed}{call}(tr2)\\
tr2\x3; \,\,\textcolor{green}{!x3\,is\,now\,local}\\
tr3=\textcolor{VioletRed}{trans}()\\
x1=-3\\
\textcolor{VioletRed}{call}(tr) \textcolor{green}{!this\,is\,causing\,division\,by\,zero}\\
/\\
Continue=1 \,\,\textcolor{green}{!\,continue\,after\,error}\\
\textcolor{VioletRed}{call}(tr3)
\end{example}
\color{Green}
\begin{verbatim}
sit>transex
<;incl(exfile,from->'transex')
<tr=trans()
<$x3=x1+3
<x2=2/$x3;
</
<tr%input,tr%output,tr%source;
tr%input is list with            2  elements:
x1 $x3
tr%output is list with            1  elements:
x2
tr%source is text object:
1 $x3=x1+3
2 x2=2/$x3;
3 /
///end of text object
<x1=8
<call(tr)
x2=0.18181818
<tr2=trans(x1,x2)
<$x3=x1+3
<x2=2/$x3;
<x3=x1+x2+$x3;
</
<tr2%input,tr2%output,tr2%source;
tr2%input is list with            1  elements:
x1
tr2%output is list with            1  elements:
x2
tr2%source is text object:
1 $x3=x1+3
2 x2=2/$x3;
3 x3=x1+x2+$x3;
4 /
///end of text object
<call(tr2)
x2=0.18181818
tr2\x3=19.1818181
<tr2\x3;
tr2\x3=19.1818181
<tr3=trans()
<x1=-3
<call(tr)
</
<Continue=1
<call(tr3)
*division by zero
*****error on row            2  in tr%source
x2=2/$x3;
recursion level set to    3.0000000000000000
*****error on row            2  in tr3%source
call(tr)
recursion level set to    2.0000000000000000
*err* transformation set=$Cursor$
recursion level set to    1.0000000000000000
****cleaned input
call(tr3)
*Continue even if error has occured
<;return
\end{verbatim}
\color{Black}
\subsection{Using a transformation object as a function}
\label{transfunc}
It is now possible to use a transformation object as a function which computes new
objects when generating arguments for functions or options,
or values of code options, or in any place within a transformation object.
If {tr} is a transformation and the transformation computes an object {A} then
{tr(A)} is first calling transformation {tr} and provides then object {A} into this place.
As the transformation computes also other objects which are computed within it, also thes objects
are available. At this point it is important to note that arguments of
a transformation line are computed from right to left, because options must be computed before
entering into a function.
\begin{example}[transfunc]Transformation as a function\\
\label{transfunc}
delete\_o(a,c)\\
tra=\textcolor{VioletRed}{trans}()\\
a=8;\\
c=2;\\
/\\
trb=\textcolor{VioletRed}{trans}()\\
a=5;\\
c=1;\\
/\\
c=2\\
a=c+trb(a)+c+tra(a);
\end{example}
\subsection{Transformation control structures}
\label{transcont}
Within \textbf{J} transformations, there can be similar controls structures as in the input programming.
The  difference  is  that  these  will  remain  as  part  of  the  transformation  set.  Only  the
'\textcolor{VioletRed}{if}()output=…'structure is allowed at the command level, other are possible only within a
transformations set.
\subsubsection{\textcolor{VioletRed}{if}()}\index{if()}
\label{if}
\textcolor{VioletRed}{if}()j\_statement… \newline
The one line if-statement.
\subsubsection{\textcolor{VioletRed}{if}() elseif() else endif}\index{if()}
\label{ifthen}
There can be 4 nested \textcolor{VioletRed}{if}()then structures. If-then-structures are not
allowed at command level.
\\
\textcolor{VioletRed}{if}()then
\\
….
\\
elseif()then
\\
…
\\
else
\\
….
\\
endif
\\
\subsection{\textcolor{VioletRed}{do}() loops}\index{do()}
\label{loops}
The loop construction in \textbf{J} looks as follows:
\\
\textcolor{VioletRed}{do}(i,start,end[,step])
\\
enddo
\\
\begin{note}
cycle and exit are implemented in the current \textbf{J} version with \textcolor{VioletRed}{goto}()oto
Within a do–loop there can be cycleand exitdostatements
\end{note}
\begin{note}
There can be 8 nested loops. do-loop is not allowed at command level.evel
\end{note}
\begin{example}[doex]do-loop\\
\label{doex}
tr=\textcolor{VioletRed}{trans}()\\
\textcolor{VioletRed}{do}(i,1,5)\\
ad1: \textcolor{VioletRed}{if}(i.eq.3)\textcolor{VioletRed}{goto}(cycle)\\
i;\\
\textcolor{VioletRed}{if}(i.eq.4)\textcolor{VioletRed}{goto}(jump)\\
cycle:enddo\\
jump:i;\\
\textcolor{VioletRed}{goto}(ad1) \,\textcolor{green}{!\,it\,is\,not\,allowed\,to\,jump\,into\,a\,loop}\\
/\\
\textcolor{VioletRed}{call}(tr)
\end{example}
\subsection{return}
\label{return}
Return from a transformation set to the transformation object where \textcolor{VioletRed}{call}()
function was, or  to the include file with \textcolor{VioletRed}{call}(), or to the \textcolor{Red}{sit>} promt,
is \textcolor{VioletRed}{call}() was at \textcolor{Red}{sit>}.
\begin{example}[retex]\\
\label{retex}
tr=\textcolor{VioletRed}{trans}()\\
r=\textcolor{VioletRed}{ran}()\\
ad1:\textcolor{VioletRed}{if}(r.lt.0.5)return\\
\textcolor{VioletRed}{goto}(ad1)\\
/\\
\textcolor{VioletRed}{call}(tr)
\end{example}
\begin{note}
return is automatically put to the end of transformation object.
\end{note}
\begin{note}
Addresses in a transformation object are without ';' as the addresses in an include file start with ';'.
\end{note}
\subsection{\textcolor{VioletRed}{errexit}()}\index{errexit()}
\label{errexit}
Function \textcolor{VioletRed}{errexit}() returns the control to \textcolor{Red}{sit>} prompt with a message similarly
as when an error occurs.
\begin{example}[errexitex]itex\\
\label{errexitex}
tr=\textcolor{VioletRed}{trans}()\\
\textcolor{VioletRed}{if}(a.eq.0)\textcolor{VioletRed}{errexit}('illegal value ',a)\\
s=3/a; \textcolor{green}{!\,division\,with\,zero\,is\,teste\,automatically}\\
/\\
a=3.7\\
\textcolor{VioletRed}{call}(tr)\\
tr(s); \textcolor{green}{!tr\,can\,also\,be\,used\,as\,a\,function}\\
a=0\\
\textcolor{VioletRed}{call}(tr)
\end{example}
\subsection{\textcolor{VioletRed}{goto}()}\index{goto()}
\label{goto}
Control can be transfered to a line in a transformation set with \textcolor{VioletRed}{goto}().
\begin{example}[gotoex]\\
\label{gotoex}
tr=\textcolor{VioletRed}{trans}()\\
i=0\\
\textcolor{VioletRed}{if}(i.eq.0)\textcolor{VioletRed}{goto}(koe)\\
'here';\\
koe:ch='here2';\\
/\\
\textcolor{VioletRed}{call}(tr)\\
ch;\\
Continue=1\\
tr=\textcolor{VioletRed}{trans}()\\
i=0\\
\textcolor{VioletRed}{if}(i.eq.0)\textcolor{VioletRed}{goto}(koe)\\
'here';\\
\textcolor{VioletRed}{do}(i,1,3)\\
koe:i;\\
enddo\\
/
\end{example}
\begin{note}
It is not allowed to jump in to a loop or into if -then structure. This is
checked already in in the interpreter.
\end{note}
\begin{note}
It is not yet possible to continue within an include file using Continue=1.
\end{note}
\begin{note}
It is not recommended to use \textcolor{VioletRed}{goto}() according to modern computation practices.
However, it was easier to implement cycle and exitdo with \textcolor{VioletRed}{goto}(), especially if
cycle or exitdo does not apply hte innermost do-loop.
\end{note}
\subsection{Numeric operations}
\label{numer}
An arithmetic expression consisting of ordinary arithmetic operations is formed in
the standard way. The operations are in the order of their precedence.
\begin{itemize}
\item[\textbf{J}] - unary minus
\item[\textbf{J}] *** integer power
\item[\textbf{J}] ** or \^ real power
\item[\textbf{J}] * multiplication
\item[\textbf{J}] / division
\item[\textbf{J}] + addition
\item[\textbf{J}] - subtraction
\end{itemize}
The reason for having a different integer power is that it is faster to compute and a negative
value can have an integer power but not a real power.
In matrix computations there are two addtional opertations.
\begin{itemize}
\item[\textbf{J}] *. elementwise product (Hadamard product)
\item[\textbf{J}] /. elementwise division
\end{itemize}
The matrix operations are explained in section ?. Their operation rules extent
the standard rules.
\subsection{Logical and relational expressions}
\label{logic}
There are following relational and logical operations. The first alternatives
follow Fortan style:
\begin{itemize}
\item[\textbf{J}] .eq. == equal to
\item[\textbf{J}] .ne. <> not equal
\item[\textbf{J}] .gt. > greater than
\item[\textbf{J}] .ge. >= greater or equal
\item[\textbf{J}].lt. < less than
\item[\textbf{J}] .le. <= less or equal
\item[\textbf{J}].not. $\sim$\,negation
\item[\textbf{J}] .and. & conjunction
\item[\textbf{J}] .or. disjunction
\item[\textbf{J}] .eqv. equivalent.
\item[\textbf{J}] .neqv. not equivalent
\end{itemize}
The relational and logical expressions produce value 1 for True and value 0 for False.
Note: Testing equivalence can be done also using 'equal to' and 'not equal', as the same truth
value is expressed with the same numeric value.
\begin{note}
when the truth value of an expression is tested with \textcolor{VioletRed}{if}(), then all nonzero real values
means that the expression is true.
\end{note}
\subsection{Arithmetic functions}
\label{arfu}
The arithmetic functions return single REAL value or a MATRIX.
\textcolor{VioletRed}{sqrt}(), \textcolor{VioletRed}{sqrt2}(), \textcolor{VioletRed}{exp}(), \textcolor{VioletRed}{log}(), \textcolor{VioletRed}{log10}(), \textcolor{VioletRed}{abs}()
\begin{itemize}
\item[\textbf{J}] \textcolor{VioletRed}{sqrt}(x) square root, \textcolor{VioletRed}{sqrt}(0) is defined to be 0, negative argument produce error.
If {x} is matrix, then an error occurs if any elemet is negative.
\item[\textbf{J}] \textcolor{VioletRed}{sqrt2}(x) If {x} or an element of {x} is negative then \$\textcolor{VioletRed}{sqrt2}()=-\textcolor{VioletRed}{sqrt}()\$. Actually \textcolor{VioletRed}{sqrt2}() might be a
useful sigmoidal function in modeling context.
\item[\textbf{J}] \textcolor{VioletRed}{exp}(x) \$e\$ to power {x}. If {x}>88, then \textbf{J} produces error in order to avoid system
crash.
\item[\textbf{J}] \textcolor{VioletRed}{log}(x) natural logarithm
\item[\textbf{J}] \textcolor{VioletRed}{log10}(x) base 10 logarithm
\item[\textbf{J}] \textcolor{VioletRed}{abs}(x) absolute value
\end{itemize}
Real to integer conversion
\begin{itemize}
\item[\textbf{J}] \textcolor{VioletRed}{nint}(x) nearest integer value
\item[\textbf{J}] \textcolor{VioletRed}{nint}(x,modulo) returns modulo*nint(x/modulo) ,e.g.\textcolor{VioletRed}{nint}(48,5)=50; \textcolor{VioletRed}{nint}(47,5)=45;
\item[\textbf{J}] \textcolor{VioletRed}{int}(x) integer value obtained by truncation
\item[\textbf{J}] \textcolor{VioletRed}{int}(x,modulo) returns modulo*int(x/modulo), e.g. \textcolor{VioletRed}{int}(48,5)=45
\item[\textbf{J}] \textcolor{VioletRed}{ceiling}(x) smallest integer greater than or equal to {x}.
\item[\textbf{J}] \textcolor{VioletRed}{ceiling}(x,modulo) returns modulo*ceiling(x/modulo), e.g. \textcolor{VioletRed}{ceiling}(47,5)=50.
\item[\textbf{J}] \textcolor{VioletRed}{floor}(x) greatest integer smaller than or equal to {x}.
\item[\textbf{J}] \textcolor{VioletRed}{floor}(x,modulo) returns modulo*floor(x/modulo), e.g. \textcolor{VioletRed}{floor}(47,5)=45.
\end{itemize}
The following rules apply both for \textcolor{VioletRed}{min}() and \textcolor{VioletRed}{max}(). The rules are presented here only for \textcolor{VioletRed}{min}().
\begin{itemize}
\item[\textbf{J}] \textcolor{VioletRed}{min}(x1,...,xn): \$n>1\$ and all arguments are REAL, \textcolor{teal}{Result} is REAL.
\item[\textbf{J}] \textcolor{VioletRed}{min}(A): If \textcolor{teal}{A} is matrix then the result result is row vector containg minumum
of each column. If \textcolor{teal}{A} is a column vector, \textcolor{teal}{Result} is REAL.
\item[\textbf{J}] \textcolor{VioletRed}{min}(A,\textcolor{blue}{any->}) If \textcolor{teal}{A} is matrix, then \textcolor{teal}{Result} minimum over all elements.
\item[\textbf{J}] \textcolor{VioletRed}{min}(x,A) If \textcolor{teal}{x} is REAL and \textcolor{teal}{A} is matrix, then \textcolor{teal}{Result} is
matrix with the same dimensions as \textcolor{teal}{A} and
\textcolor{teal}{Result}(i,j)=\textcolor{VioletRed}{max}(\textcolor{teal}{x},\textcolor{teal}{A}(i,j)). The order of arguments does not matter.
\item[\textbf{J}] \textcolor{VioletRed}{min}(A,B), \textcolor{teal}{A} and \textcolor{teal}{B} compatible matrices. \textcolor{teal}{Result} is amatrix with the same dimesnions containg elementwise
minimums.
\end{itemize}
\subsubsection{Matrices and vectors}
\label{matrixo}
Matrices and vectors are generated with the \textcolor{VioletRed}{matrix}() function or they are
produced by matrix operations, matrix functions or by other \textbf{J} functions. E.g.
the \textcolor{VioletRed}{data}() function is producing a data matrix as a part of the compound data
object. Matrix elements can be used in arithmetic operations as input or output
in similar way as real variables.
See Matrix computations.
\subsection{Matrix functions}
\label{matrixf}
There are matrix function which can create matrices (objects with type Matrix), take submatrices from larger matrices,
make matrices from submatrices, compute statitics from matrices, solve linear equations,
compute inverse and transpose of a matrix.
Sums, differences and products of matrices are defined using ordinary arithmetic
operations +,- and *. Arithmetic operations can combine scalars and matrices in the normal way.
Now all matrices are in double precision.
The arithemetic operations work for matrices as follows for arguments \textcolor{teal}{a1} and \textcolor{teal}{a2}
\begin{itemize}
\item[\textbf{J}] \textcolor{teal}{a1} + \textcolor{teal}{a2}
\begin{itemize}
\item[\textbf{J}] \textcolor{teal}{a1} and \textcolor{teal}{a2} can be compatibe matrices
\item[\textbf{J}] \textcolor{teal}{a1} or \textcolor{teal}{a2} can be scalar (REAL) and the other argument is MATRIX.
\item[\textbf{J}] \textcolor{teal}{a1} or \textcolor{teal}{a2} can be row vector and the other argument
can be matrix having the same number
of columns. Then the row vector is added to each row of the matrix. This is NONSTADARD.
Similarly the other argument can be a colun vector and the other argument matrix having the same number of rows.
Then the vector is added to each column of the matrix. NONSTANDARD.
\end{itemize}
\end{itemize}
The same computation rules apply for operations -, *. (elementwise product), and
/. (elemetwise division). The same rules apply also for logical operations,
except the nonstandard rules do not apply.
For multiplication \textcolor{teal}{a1} * \textcolor{teal}{a2}, either of the arguments can be scalar,
and the other matrix or LIST of REAL objects.
When \textcolor{teal}{a1} and \textcolor{teal}{a2} are matrices, standar matrix multiplication rules apply.
When \textcolor{teal}{a1} or \textcolor{teal}{a2} is LIST of REAL values then, it works exacty as
a column vector, when it is on the input side.  The elements are eqaul
to the values of the REAL elements. When a LIST is an output of matrix
computaions, the an error occurs if the output of the matrix operation is
not comaptibel with the number of elemets in the LIST.
\begin{example}[matrixop]Matrix operations\\
\label{matrixop}
A=\textcolor{VioletRed}{matrix}(3,4,\textcolor{blue}{do->});\\
A+2;\\
A-1;\\
2*A;\\
A*.\textcolor{VioletRed}{matrix}(3,4,\textcolor{blue}{do->}2);\\
A/.A;\\
b=\textcolor{VioletRed}{matrix}(4,\textcolor{blue}{values->}(1,3,6,8));\\
A*b;\\
Continue=1 \,\textcolor{green}{!Error}\\
A*.b;\\
A+b(1,-3); \,\textcolor{green}{!\,NONSTANDARD}\\
B=\textcolor{VioletRed}{matrix}(3,4,\textcolor{blue}{values->}2);\\
A.eq.B;\\
li=\textcolor{VioletRed}{list}(x1...x3)\\
li=\textcolor{VioletRed}{matrix}(3,\textcolor{blue}{do->});\\
@li;\\
A+li;\\
b*A;\\
A+\textcolor{VioletRed}{t}(b);\\
li=\textcolor{VioletRed}{matrix}(4,\textcolor{blue}{do->});\\
Continue=0
\end{example}
\subsection{Create a matrix: \textcolor{VioletRed}{matrix}()}\index{matrix()}
\label{matrix}
Function \textcolor{VioletRed}{matrix}() creates a matrix and puts REAL values to the elements. Element values
can be read from the input paragraph, file, or the values can be generated
using \textcolor{blue}{values->} option, or sequential values can be generated
using \textcolor{blue}{do->} option. Function \textcolor{VioletRed}{matrix}() can generate a diagonal and block diagonal matrix.
A matrix can be generated from submatrices by using matrices as arguments
of the  \textcolor{blue}{values->} option. It should be noted that matrices are stored in row order.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}   MATRIX | REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  If a 1x1 matrix is defined, the output will be REAL.
The output can be a temporary matrix without name, if \textcolor{VioletRed}{matrix}() is an argument
of an arithmetic function  or matrix function. If no element values are
given in \textcolor{blue}{values->} or obtained from \textcolor{blue}{in->} input, all elemets get value zero.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 0-2 \tabto{5cm}  REAL \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The dimension of the matrix. The first argument gives the number of rows,
the second argument, if present, the number of columns.  If the matrix is generated from submatrices given in \textcolor{blue}{values->}, then the dimensions
refer to the submatrix rows and submatrix columns. If there are no arguments, then the
it should be possible to infer the dimensions from \textcolor{blue}{values->} option. If the
first argument is \textcolor{teal}{Inf}, the the number of rows is determined by the number
number of lines in source determined by \textcolor{blue}{in->}.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{in} \tabto{3cm} N|0|1 \tabto{5cm}  CHAR \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The input for values. \textcolor{blue}{in->} means that values are read in from
the following input paragraps, \textcolor{blue}{in->}\textcolor{teal}{file} means that the values are read from file.
in both cases a record must contain one row for the matrix.
If there is reading error and values are read from the terminal, \textbf{J} gives
possibility to continue with better luck, otherwise an error occurs.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{values} \tabto{3cm} N|1- \tabto{5cm}   REAL  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent values or MATRIX objects put to the matrix. The argumenst of
\textcolor{blue}{values->} option go in the regular way
through the interpreter, so the values can be obtained by computations. If only one REAL value is
given then all diagonal elements are put equal to the value (ohers will be zero),
if \textcolor{blue}{diag->} option is present, otherwise all elements are put equal to this value. If matrix dimensions
are given, and there are fewer values than is the size the matrix, matrix is
filled row by row using all values given in
\textcolor{blue}{values->}. If there are more values as is the size, an error occurs unless there is
\textcolor{blue}{any->} option present.
Thus \textcolor{VioletRed}{matrix}(N,N,\textcolor{blue}{values->}1) generates the identity matrix.
If value-> refers to one MATRIX,and \textcolor{blue}{diag->} is present then a block diagonal
matrix is generated. Without \textcolor{blue}{diag->}, a partitioned matrix is generated having all
submatrices equal
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent \textcolor{blue}{do}  \tabto{3cm} N|0-3 \tabto{5cm}  REAL   \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  A matrix of number sequences is generated, as followsws: \newline
\textcolor{blue}{do->} Values 1,2,...,\textcolor{teal}{arg1} x \textcolor{teal}{arg2} are put into the matrix in the row order. \newline
\textcolor{blue}{do->}5 Values 5,6,...,\textcolor{teal}{arg1} x \textcolor{teal}{arg2}+4 are put into the matrix \newline
\textcolor{blue}{do->}
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[matrixex]Example of generating matrices\\
\label{matrixex}
A=\textcolor{VioletRed}{matrix}(3,
\end{example}
\subsection{\textcolor{VioletRed}{getelem}(): extracting information from an object}\index{getelem()}
\label{getelems}
The origin of this function is the function which was used in previous versions
to take an matrix element, which explains the name. Now it is used to extract
also submatrices (e.g. a(1,-3,All)) , or to get value of an regression
function or to compute
a transforamtion and then take argument object as the result. E.g. if \textcolor{teal}{tr} is a transformation
then the result of  \textcolor{teal}{tr}(\textcolor{teal}{a}) is object \textcolor{teal}{a} after calling \textcolor{teal}{tr}.
\begin{note}
If someone starts to use the own function property of the open source J, she/he
probably would like to get the possiblity to extract information from her/his object types
also. To implement this property requires some co-operation from my side.
\end{note}
\section{n datahead}
\label{datahead}
Data can be analyzed and processed either using matrix computations
or using DATA objects. A DATA object is compound object
linked to a data MATRIX and LIST object containing variable (column) names,
some other information.
When data ere used via DATA object in statistical or linear programming
functions, the data are processed observarion by observation.
It is possible to work using DATA object or using directly the data matrix, wharever is more
convenient. It is posible make new data objects or new matrices
by to extracting  columns of data matrix, computing matrices with matrix computations.
It is possible to use data in hierarcchila way, This property is inherited fro JLP.
There are two \textbf{J} functions which create DATA objects from files, \textcolor{VioletRed}{data}() and
exceldta(). \textcolor{VioletRed}{data}() can create hierarchical data objects. Function \textcolor{VioletRed}{newdata}() creates  DATA object from matrices, which temselfs can be
picked from data objects. Function \textcolor{VioletRed}{linkdata}() can link two data sets to make a hierarchical data.
\begin{note}
If a data file contains columns which are referred with variable names and some vectors,
the it is practical to read data first into a matrix using \textcolor{VioletRed}{matrix}() function and then
use matrix operations and \textcolor{VioletRed}{newdata}() to make DATA object with variable names and matrices.
See Simulator section for an example.
\end{note}
\begin{note}
\textcolor{VioletRed}{transdata}() function goes through DATA object similarly as statitical functions, but
does not serve a specific purpose, just transforamtions defined in the TRANS object refreed with
\textcolor{blue}{trans->} option are computed. See again the simulator section.
\end{note}
\begin{note}
In earlier versions it was possible to give several data sets as arguments for \textcolor{blue}{data->} option.
This festure is now deleted as it is possible to stack several data matrices and then use \textcolor{VioletRed}{newdata}() function to create a single data set.
\end{note}
\subsubsection{Text objects}
\label{textob}
Currently there are two text object types, the old text object TEXT and the new
TXT. The TEXT object stores text in a long vector of single characters. The TXT
object stores text in lines of 132 characters. The TEXT objects save memory but
are not so easy to modify and use. Several \textbf{J}
functions create associated text objects. \textbf{J} functions \textcolor{VioletRed}{text}() and \textcolor{VioletRed}{txt}()
can be used to
create text objects directly. All the names of \textbf{J} objects are also stored in a
TEXT object called Names. The number of lines in a text objects can be obtained
with \textcolor{VioletRed}{nrows}() function and the total number of characters can be obtained with
\textcolor{VioletRed}{len}() function.
\section{Figures}
\label{figu}
Figures are made using Gnuplot. \textbf{J} transmits information into Gnuplot using text files.
\textbf{J} generates the files using .jfig extension. Necessary files are generated  by deleting old
files without asking permission. If \textcolor{teal}{fig} is the output of a figure function, then
\textbf{J} creates always, except in 3D, file with name \textcolor{teal}{fig}.jfig and possibly other files with
.jfi0, jfi1  etc extensions.
All figure functions use the following options.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output  \tabto{3cm}  1 \tabto{5cm}   FIGURE  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The FIGURE object created or updated
@@figure
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{note}
is possible to show a figure using \textcolor{VioletRed}{show}() function. It can have either the \textcolor{teal}{fig} object as the
argument or the file name of \textcolor{teal}{fig}.jfig -file. Thus it is possible
to edit the file using Gnuplot capabilites.
\end{note}
\begin{note}
It is possible to change the terminal type used by Gnuplot by giving
the name of the terminal to the predefine CHAR variable \textcolor{teal}{Terminal}.
The default is \newline \textcolor{teal}{Terminal}='qt'.
\end{note}
\begin{note}
The default writte by Gnuplot does not look nice and is not implemented.
The user can write own legends using \textcolor{blue}{label->} option in \textcolor{VioletRed}{drawline}().
\end{note}
\begin{note}
Easiest way to delete an nonmatrix object \textcolor{teal}{fi} is \textcolor{teal}{fi}=0, which makes it possible
to use \textcolor{blue}{append->} also for an \textcolor{teal}{fi} wihtout the need to construct if then-
structures.
\end{note}
\subsubsection{Figure object}
\label{figureo}
Graphic functions produce FIGURE objects. Each FIGURE object can consist of
several subfigures. Each FIGURE object stores information of x- and y axes, the
range of all x- and y-values, and for each sub-figure information of the ranges
of x and y in the subfigure plus the subfigure type and the needed data values.
Currently, when Gnuplot is used for graphics, most data values are stored
in text files which Gnuplot reads. Function \textcolor{VioletRed}{plot3d}() is plotting 3-d figures without making a FIGURE object.
See Plotting figures for more information.
\section{Statistical functions}
\label{statistics}
There are several statistical functions which can be used to compute basic statistics
linear and and nonlinear regression, class means, standard deviations and standard errors
in one or two dimensional tables using data sets. There are also functions
which can be used to compute statistics from matrices, but these are described
in Section  \ref{matrix}
\subsection{The main components of \textbf{J} program}
\label{compo}
The structure of \textbf{J} program
\begin{itemize}
\item[\textbf{J}] Input programming which generates text input for the interpreter (subroutine
j\_getinput). \textbf{J} commands are obtained:
\begin{itemize}
\item[\textbf{J}] from \textcolor{Red}{sit>} prompt
\item[\textbf{J}] form possibly nested include files
\end{itemize}
\item[\textbf{J}] Interpreter which generates from text lines integer vectors containing function indices,
option indices and object indices (subroutine j\_interpret).
\item[\textbf{J}] Function driver which executes the code in the interpreted integer vector
(subroutine dotrans). The the function driver is using:
\begin{itemize}
\item[\textbf{J}] \textbf{J} functions which operate on arguments which are determined either as formal arguments or
via options.
\item[\textbf{J}] \textbf{J} objects
\item[\textbf{J}] Global variables and matrices
\item[\textbf{J}] Utility subroutines
\end{itemize}
\end{itemize}
A user of \textbf{J} needs only input programming and \textbf{J} functions, but understanding of
the other properties may help to understand waht is going on in a \textbf{J} session.
\subsection{stributions}
\label{distributions}
Currently there are sepcial functions for the density funtion \textcolor{VioletRed}{pdf}() of normal distribution,
cumulative distribution function \textcolor{VioletRed}{cdf}() for normal and chi2 distributions,
frequncy funtion for binomial distribution, and frequnce funtion \textcolor{VioletRed}{negbin}() for the
negative binomial distribution (providing Poisson as a special case).
\section*{o1\_o1\_funcs(), o2\_funcs() and o3\_funcs()}
EXTRAAAAAAAAAAAAAAA
These functions are used to trasnmit control into the own functions of
own1, own2 or own3 -users. See the Developers manual.
\section*{delete\_omika(): delete an object}
EXTRAAAAAAAAAAAAAAA
delete\_o(\textcolor{teal}{Obj}) deallocates all the allocated components of the object and
makes the object a REAL variable (it is not possible to remove object names).
An charcter constant cannot be deleted. If a character variable (i.e. an oobject pointing
to a character constant) is associated with an open file, it cannot be
deleted before closing the file.
\begin{note}
In previous versions files and objects were deleted with the same delete() function
which was potentially dangerous.
\end{note}
\section*{pupua}
EXTRAAAAAAAAAAAAAAA
\textbf{J} is a general program for doing different tasks in data analysis, matrix computations,
simulation and optimization. It is intended to be used mainly in different forestry related
applications. It has superseded the previous linear programming software JLP (Lappi 1992).
Most users are interested in applying \textbf{J} in linear programming problems of forest management
planning. Linear programming functions and examples are described in chapter 11. \textbf{J} version
2.0 is introducing factory problems where transportation costs and factory capacities can be
taken into account. Factory problems are also described in chapter 11. Shortest route to linear
programming problems is to read basics of command generation programming from chapter
3.2, at least \textcolor{Red}{;incl}() function from chapter 3.2.3. Forestry LP-problem requires also use of
\textcolor{VioletRed}{data}() function (chapter 9.1) and usually also \textcolor{VioletRed}{linkdata}() function (chapter 9.3). LPproblems are defined with \textcolor{VioletRed}{problem}() function (chapter 11.5) and the problems are solved
with \textcolor{VioletRed}{jlp}() function (chapter 11.7). After version 2.1 it is possible to solve large ordinary linear
programming problems without \textcolor{VioletRed}{problem}() function using \textcolor{blue}{zmatrix->} option in \textcolor{VioletRed}{jlp}()
function. To access the weights of optimal treatment schedules and to get them into files
requires use of J-transformations (chapter 4.) inquiry functions (chapter 11.11), IO-functions
(chapter 8), loops (chapter 7.2). An example is given in chapter 11.
!
\textbf{J} is operated using text command lines, but it contains tools which make this kind of operation
mode more efficient, e.g. input can be included from files so that a part of the input lines is
reinterpreted, input lines can be generated using loop constructs etc. These properties are
called here as input programming.
\section*{Storage for variables}
EXTRAAAAAAAAAAAAAAA
Especially in a simulator it may happen that a set of variables have certain
values but the same variables are used for other purposes for some time and
then one would like to get the previous values. There is special \textbf{J} object used
to store the values, and special store() and load() functions to deal with the
storage.
\section*{Trace set}
EXTRAAAAAAAAAAAAAAA
TRACESET is an object created by ;trace() function which is used by
\textcolor{VioletRed}{tracetest}() function to test if a set of variables has been updated. See
chapter Tracing variables.
\section*{Analyzing classified data}
EXTRAAAAAAAAAAAAAAA
The are several functions which can be used to analyze classified data.
All these functions are described here, even if they belong Figure functions and
statistical functions.
\section*{Data functions}
EXTRAAAAAAAAAAAAAAA
Data functions can generate data objects by reading data from files, or forming data
objects by combing matrices and data objects. An important property of data objects
is that they can be linked so that each observation of an upper level data
is linked to several observations in lower level data. Each upper level
observation can contain different number of lower level observations.
Linear programming in forest management planning is based on linked data sets where each
stand is connected to number of treatment schedules.
\section*{Defining LIST2 object for named object and constants.}
EXTRAAAAAAAAAAAAAAA
The LIST2 object is simialr to LIST object but it can contain also
indices of REAL constants in addition to named objects.
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}   LIST2  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent The generated LIST2 object.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm}  0-  \tabto{5cm}     \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  named objects or constants. If an argument is LIST it is ex+panded
first.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[list2ex]\\
\label{list2ex}
lis2=\textcolor{VioletRed}{list2}(x1...x4,3,5);\\
li1=\textcolor{VioletRed}{list}(x1,x2);\\
li2=\textcolor{VioletRed}{list}(z,y);\\
lis=\textcolor{VioletRed}{list2}(li1,li2,77);
\end{example}
\section*{Difference of LIST objects}
EXTRAAAAAAAAAAAAAAA
\textcolor{VioletRed}{difference}() removes elements from a LIST
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Output \tabto{3cm}  1 \tabto{5cm}  LIST  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  the generated LIST.
\end{changemargin}
\vspace{0.3cm}
\hline
\vspace{0.3cm}
\noindent Args \tabto{3cm} 2 \tabto{5cm}  LIST|OBJ  \tabto{7cm}
\begin{changemargin}{3cm}{0cm}
\noindent  The first argument gives the LIST from which the elements of of the
are removed  If second argument is LIST then all of its eleemts are remove, other wise
it is assumed that the second argument is an object which is remode from the lisrt.
\end {changemargin}
\hline
\vspace{0.2cm}
\begin{example}[diffex]fex\\
\label{diffex}
lis=\textcolor{VioletRed}{list}(x1...x3,z3..z5);\\
lis2=\textcolor{VioletRed}{list}(x1,z5);\\
liso=\textcolor{VioletRed}{difference}(lis,lis2);\\
liso2=\textcolor{VioletRed}{difference}(liso,z3);\\
Continue=1\\
lisoer=\textcolor{VioletRed}{difference}(lis,z6); \textcolor{green}{!\,error\,occurs}\\
liser=\textcolor{VioletRed}{difference}(Lis,x3); \,\textcolor{green}{!error\,occurs}\\
Continue=0
\end{example}
